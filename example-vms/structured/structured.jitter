## Jitter specification for a stack VM, used in the structured language example.

## Copyright (C) 2017 Luca Saiu
## Written by Luca Saiu

## This file is part of Jitter.

## Jitter is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.

## Jitter is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.

## You should have received a copy of the GNU General Public License
## along with Jitter.  If not, see <http://www.gnu.org/licenses/>.


## Global configuration.
#################################################################

vm
  set prefix "structuredvm"
  tos-stack "jitter_int" "mainstack"
end


## Register classes.
#################################################################

register-class r 2
  code
    union jitter_word
  end
end


## Functions and globals to wrap.
#################################################################

wrapped-functions
  printf
end

wrapped-globals
  stack_printf_format_string
end

early-c
  code
#   include <stdio.h>
  end
end
late-c
  code
    static const char *stack_printf_format_string = "%" JITTER_PRIi "\n";
  end
end


## Custom literal argument printer.
#################################################################

printer-c
  code
static void
my_literal_printer (FILE *out, jitter_uint u)
{
  fprintf (out, "%" JITTER_PRIu, u);
}
  end
end


## Instructions.
#################################################################

instruction nop ()
  code
  end
end

instruction drop ()
  code
    JITTER_DROP_MAINSTACK();
  end
end

instruction push (?Rnl 0 1 -1 2 my_literal_printer)
  code
    jitter_int k = JITTER_ARGN0;
    JITTER_PUSH_MAINSTACK(k);
  end
end

instruction pop (!R)
  code
    jitter_int top = JITTER_TOP_MAINSTACK();
    JITTER_DROP_MAINSTACK();
    JITTER_ARGN0 = top;
  end
end

instruction print ()
  non-relocatable
  code
    jitter_int top = JITTER_TOP_MAINSTACK();
    JITTER_DROP_MAINSTACK();
    printf (stack_printf_format_string, top);
  end
end

instruction plus ()
  code
#define F(res, a, b) { res = a + b; }
    JITTER_BINARY_MAINSTACK(F);
#undef F
  end
end

instruction uminus ()
  code
    JITTER_TOP_MAINSTACK() = - JITTER_TOP_MAINSTACK();
  end
end

instruction minus ()
  code
#define F(res, a, b) { res = a - b; }
    JITTER_BINARY_MAINSTACK(F);
#undef F
  end
end

instruction times ()
  code
#define F(res, a, b) { res = a * b; }
    JITTER_BINARY_MAINSTACK(F);
#undef F
  end
end

instruction divided ()
  code
#define F(res, a, b) { res = a / b; }
    JITTER_BINARY_MAINSTACK(F);
#undef F
  end
end

instruction remainder ()
  code
#define F(res, a, b) { res = a % b; }
    JITTER_BINARY_MAINSTACK(F);
#undef F
  end
end

instruction equal ()
  code
#define F(res, a, b) { res = (a == b); }
    JITTER_BINARY_MAINSTACK(F);
#undef F
  end
end

instruction different ()
  code
#define F(res, a, b) { res = (a != b); }
    JITTER_BINARY_MAINSTACK(F);
#undef F
  end
end

instruction less ()
  code
#define F(res, a, b) { res = (a < b); }
    JITTER_BINARY_MAINSTACK(F);
#undef F
  end
end

instruction lessorequal ()
  code
#define F(res, a, b) { res = (a <= b); }
    JITTER_BINARY_MAINSTACK(F);
#undef F
  end
end

instruction greater ()
  code
#define F(res, a, b) { res = (a > b); }
    JITTER_BINARY_MAINSTACK(F);
#undef F
  end
end

instruction greaterorequal ()
  code
#define F(res, a, b) { res = (a >= b); }
    JITTER_BINARY_MAINSTACK(F);
#undef F
  end
end

instruction logicaland ()
  code
#define F(res, a, b) { res = (a && b); }
    JITTER_BINARY_MAINSTACK(F);
#undef F
  end
end

instruction logicalor ()
  code
#define F(res, a, b) { res = (a || b); }
    JITTER_BINARY_MAINSTACK(F);
#undef F
  end
end

instruction logicalnot ()
  code
    JITTER_TOP_MAINSTACK() = ! JITTER_TOP_MAINSTACK();
  end
end

instruction b (?f)
  code
    JITTER_BRANCH_FAST(JITTER_ARGF0);
  end
end

instruction bt (?f)
  code
    jitter_int top = JITTER_TOP_MAINSTACK();
    JITTER_DROP_MAINSTACK();
    JITTER_BRANCH_FAST_IF_NONZERO(top, JITTER_ARGF0);
  end
end

instruction bf (?f)
  code
    jitter_int top = JITTER_TOP_MAINSTACK();
    JITTER_DROP_MAINSTACK();
    JITTER_BRANCH_FAST_IF_ZERO(top, JITTER_ARGF0);
  end
end


## Rewriting.
#################################################################

rewriter-c
  code


/////////////////////////////////////////////////////////////

  /*
// rule equali0-to-not rewrite equali 0 into not end
JITTER_RULE_BEGIN(1)
  JITTER_RULE_BEGIN_PLACEHOLDER_DECLARATIONS
  JITTER_RULE_END_PLACEHOLDER_DECLARATIONS
  JITTER_RULE_BEGIN_CONDITIONS
    JITTER_RULE_CONDITION_MATCH_OPCODE(0, equali)
    JITTER_RULE_CONDITION_MATCH_LITERAL_ARGUMENT(0, 0, 0)
  JITTER_RULE_END_CONDITIONS
  JITTER_RULE_BEGIN_PLACEHOLDER_CLONING
  JITTER_RULE_END_PLACEHOLDER_CLONING
  JITTER_RULE_BEGIN_BODY
    JITTER_RULE_APPEND_INSTRUCTION_(logicalnot);
  JITTER_RULE_END_BODY
  JITTER_RULE_BEGIN_PLACEHOLDER_DESTRUCTION
  JITTER_RULE_END_PLACEHOLDER_DESTRUCTION
JITTER_RULE_END

// rule not-not->nothing rewrite when logicalnot logicalnot into end
JITTER_RULE_BEGIN(2)
  JITTER_RULE_BEGIN_PLACEHOLDER_DECLARATIONS
  JITTER_RULE_END_PLACEHOLDER_DECLARATIONS
  JITTER_RULE_BEGIN_CONDITIONS
    JITTER_RULE_CONDITION_MATCH_OPCODE(0, logicalnot)
    JITTER_RULE_CONDITION_MATCH_OPCODE(1, logicalnot)
  JITTER_RULE_END_CONDITIONS
  JITTER_RULE_BEGIN_PLACEHOLDER_CLONING
  JITTER_RULE_END_PLACEHOLDER_CLONING
  JITTER_RULE_BEGIN_BODY
    fprintf (stderr, "Within the not-not->nothing body\n");
  JITTER_RULE_END_BODY
  JITTER_RULE_BEGIN_PLACEHOLDER_DESTRUCTION
  JITTER_RULE_END_PLACEHOLDER_DESTRUCTION
JITTER_RULE_END

// rule rewrite pop $a; push $a into copy-to-r $a end
JITTER_RULE_BEGIN(2)
  JITTER_RULE_BEGIN_PLACEHOLDER_DECLARATIONS
    JITTER_RULE_DECLARE_PLACEHOLDER_(a);
  JITTER_RULE_END_PLACEHOLDER_DECLARATIONS
  JITTER_RULE_BEGIN_CONDITIONS
    JITTER_RULE_CONDITION_MATCH_OPCODE(0, pop)
    JITTER_RULE_CONDITION_MATCH_PLACEHOLDER(0, 0, a)
    JITTER_RULE_CONDITION_MATCH_OPCODE(1, push)
    JITTER_RULE_CONDITION_MATCH_PLACEHOLDER(1, 0, a)
  JITTER_RULE_END_CONDITIONS
  JITTER_RULE_BEGIN_PLACEHOLDER_CLONING
    JITTER_RULE_CLONE_PLACEHOLDER_(a);
  JITTER_RULE_END_PLACEHOLDER_CLONING
  JITTER_RULE_BEGIN_BODY
    JITTER_RULE_APPEND_INSTRUCTION_(copy_mto_mr);
    JITTER_RULE_APPEND_PLACEHOLDER_(a);
  JITTER_RULE_END_BODY
  JITTER_RULE_BEGIN_PLACEHOLDER_DESTRUCTION
    JITTER_RULE_DESTROY_PLACEHOLDER_(a);
  JITTER_RULE_END_PLACEHOLDER_DESTRUCTION
JITTER_RULE_END
  */
  end
end

# rule
# # pop-push-to-move
#   rewrite
#     add ?R, ?Rn, ?R
#     nop
#   into
# #    copy-to-r ?R
# end

rule not-not--nothing rewrite logicalnot; logicalnot into end
rule not-bf--bt rewrite logicalnot; bf $a into bt $a end
rule not-bt--bf rewrite logicalnot; bt $a into bf $a end
rule less-not--greaterorequal rewrite less; logicalnot into greaterorequal end
rule lessorequal-not--greater rewrite lessorequal; logicalnot into greater end
rule greater-not--lessorequal rewrite greater; logicalnot into lessorequal end
rule greaterorequal-not--less rewrite greaterorequal; logicalnot into less end
rule push-pop-- rewrite push R $a; pop R $a into end
rule push-pop--rtor rewrite push R $a; pop R $b into r-to-r $a, $b end
rule push-pop--setr rewrite push n $a; pop R $b into set-r $a, $b end
rule push-plus--plusi rewrite push n $a; plus into plusi $a end
# rule push-plusi--push rewrite push n $a; plusi n $b into push plus($a, $b) end

rule push-equal--equali rewrite push n $a; equal into equali $a end
rule equali-bt--beqi rewrite equali n $a; bt $b into beqi $a, $b end
rule equali-bf--bneqi rewrite equali n $a; bf $b into bneqi $a, $b end

rule push-drop-- rewrite push $a; drop into end
rule push-push--push-dup rewrite push $a; push $a into push $a; dup end

rule push-bf--b rewrite push 0; bf $a into b $a end

# rule equali0-to-not when is_zero ($a) rewrite equali $a into not end

## Optimized instructions (scratch).
#################################################################

instruction dup ()
  code
    JITTER_DUP_MAINSTACK();
  end
end

instruction set-r (?n 0 1 2 -1 my_literal_printer, !R)
  code
    JITTER_ARGN1 = JITTER_ARGN0;
  end
end

instruction copy-to-r (!R)
  code
    JITTER_ARGN0 = JITTER_TOP_MAINSTACK();
  end
end

instruction r-to-r (?R, !R)
  code
    JITTER_ARGN1 = JITTER_ARGN0;
  end
end

instruction plusi (?n -1 0 1 2 my_literal_printer)
  code
    JITTER_TOP_MAINSTACK() += JITTER_ARGN0;
  end
end

instruction minusi (?n 0 1 2 my_literal_printer)
  code
    JITTER_TOP_MAINSTACK() -= JITTER_ARGN0;
  end
end

instruction minusr (?R)
  code
    JITTER_TOP_MAINSTACK() -= JITTER_ARGN0;
  end
end

instruction equali (?n 0 1 2 my_literal_printer)
  code
    JITTER_TOP_MAINSTACK() = (JITTER_TOP_MAINSTACK() == JITTER_ARGN0);
  end
end

instruction differenti (?n 0 1 2 my_literal_printer)
  code
    JITTER_TOP_MAINSTACK() = (JITTER_TOP_MAINSTACK() != JITTER_ARGN0);
  end
end

instruction beqi (?n -1 0 1 2 my_literal_printer, ?f)
  code
    jitter_int top = JITTER_TOP_MAINSTACK();
    JITTER_DROP_MAINSTACK();
    JITTER_BRANCH_FAST_IF_EQUAL(top, JITTER_ARGN0, JITTER_ARGF1);
  end
end

instruction bneqi (?n -1 0 1 2 my_literal_printer, ?f)
  code
    jitter_int top = JITTER_TOP_MAINSTACK();
    JITTER_DROP_MAINSTACK();
    JITTER_BRANCH_FAST_IF_NOTEQUAL(top, JITTER_ARGN0, JITTER_ARGF1);
  end
end

instruction beqr (?R, ?f)
  code
    jitter_int top = JITTER_TOP_MAINSTACK();
    JITTER_DROP_MAINSTACK();
    JITTER_BRANCH_FAST_IF_EQUAL(top, JITTER_ARGN0, JITTER_ARGF1);
  end
end

instruction bneqr (?R, ?f)
  code
    jitter_int top = JITTER_TOP_MAINSTACK();
    JITTER_DROP_MAINSTACK();
    JITTER_BRANCH_FAST_IF_NOTEQUAL(top, JITTER_ARGN0, JITTER_ARGF1);
  end
end

instruction bger (?R, ?f)
  code
    jitter_int top = JITTER_TOP_MAINSTACK();
    JITTER_DROP_MAINSTACK();
    JITTER_BRANCH_FAST_IF_NOTLESS_SIGNED(top, JITTER_ARGN0, JITTER_ARGF1);
  end
end

instruction pushr-minusr-pop (?R, ?R, !R)
  code
    JITTER_ARGN2 = JITTER_ARGN0 - JITTER_ARGN1;
  end
end

instruction pushr-beqr (?R, ?R, ?f)
  code
    JITTER_BRANCH_FAST_IF_EQUAL(JITTER_ARGN0, JITTER_ARGN1, JITTER_ARGF2);
  end
end

instruction pushr-bger (?R, ?R, ?f)
  code
    JITTER_BRANCH_FAST_IF_NOTLESS_SIGNED(JITTER_ARGN0, JITTER_ARGN1,
                                         JITTER_ARGF2);
  end
end
