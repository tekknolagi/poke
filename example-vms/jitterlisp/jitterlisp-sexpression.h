/* Jittery Lisp: s-expression header.

   Copyright (C) 2017 Luca Saiu
   Written by Luca Saiu

   This file is part of the Jittery Lisp language implementation, distributed as
   an example along with Jitter under the same license.

   Jitter is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Jitter is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Jitter.  If not, see <http://www.gnu.org/licenses/>. */


#ifndef JITTERLISP_SEXPRESSION_H_
#define JITTERLISP_SEXPRESSION_H_

#include <stdbool.h>

/* We need the jitter_int and jitter_uint types. */
#include <jitter/jitter.h>

/* We rely on our CPP general-purpose macros, in particular for token
   concatenation. */
#include <jitter/jitter-cpp.h>




/* About this file.
 * ************************************************************************** */

/* This header provides definitions for building efficient dynamically-typed
   systems where values can be encoded, decoded and checked for type.

   This generic infrastructure is designed to be built upon to define each type
   in a specific system. */




/* Correctness and performance caveats.
 * ************************************************************************** */

/* Some of the macro defined in this header may evaluate their arguments
   multiple times.  Even if this situation currently applies to a small number
   of cases such details may easily change in the future and should not be
   relied upon.
   The user should not pass C expressions with side effects as arguments to the
   macros defined here.

   Tag configurations, tag lengths and header tags should be compile-time
   constants.  Everything should still work even if those values were not known
   at compile time but there would be a considerable performance impact.

   Like Jitter-generated code, this code is designed to be *always* compiled
   with optimization; in particular some macros may expand to C conditional
   expressions with compile-time constants as conditions, meant to reduce to
   just one of the two branches at compile time.  The macros provided here
   should be very orthogonal and individually simple, but were written keeping
   in mind the assembly code generated by a good C compiler.

   The user is not supposed to directly access tags and stags from ordinary
   code, as the specific details each type encoding may depend on the
   configuration, and should be easy to tweak for efficiency.  Instead the user
   should call type-specific macros, built on top of the definitions here,
   for type checking, tagging and untagging. */




/* A C type for dynamically-typed objects.
 * ************************************************************************** */

/* A dynamically-typed object is, by convention, represented as a C unsigned
   integer.

   This type has the same width as a hardware machine word (jitter_int and
   jitter_uint are defined to be exactly as wide as a C pointer), so that they
   fit in hardware registers.

   An object whose entire value or state is held in the jitter_tegged_object,
   without referring to memory, is called "unboxed".

   A dynamically-typred "boxed" object instead encodes a pointer to memory,
   where more information is stored in some form suitable to the object type. */
typedef jitter_uint jitter_tagged_object;




/* Bitwise expression utility.
 * ************************************************************************** */

/* The words taken as arguments by the macros in this section and evaluated to
   by their expansions are all unsigned, of size sizeof (jitter_uint). */

/* Expand to an r-value evaluating to the most significant bit of the given
   word, not shifted. */
#define JITTER_MOST_SIGNIFICANT_BIT(_jitter_word)      \
  (((jitter_uint) (_jitter_word))                      \
   & ((jitter_uint) 1) << (JITTER_BITS_PER_WORD - 1))

/* Expand to an r-value evaluating to a bitmask matching the given number of
   least significant bits in a word. */
#define JITTER_BIT_MASK(_jitter_bit_no)          \
  ((((jitter_uint) 1) << (_jitter_bit_no)) - 1)

/* Expand to an r-value evaluating to a bit mask with the given number of
   consecutive 1 bits, the first one starting at the most significant position
   in a word. */
#define JITTER_HIGH_BIT_MASK(_jitter_bit_no)  \
  (JITTER_BIT_MASK(_jitter_bit_no)            \
   << (JITTER_BITS_PER_WORD - (_jitter_bit_no)))

/* Expand to an r-value evaluating to the given word with the given number of
   its least significant bits set to zero.  No side effects.  Rationale: this
   has the advantage of working independently from the original {p,s,}tag but
   might not be the most efficient solution when the original configuration is
   known; in particular these operations is more difficult for GCC to optimize
   away by combining them with arithmetic, including address arithmetic. */
#define JITTER_WITH_BITS_MASKED_OFF(_jitter_word,    \
                                    _jitter_bit_no)  \
  (((jitter_uint) (_jitter_word))                    \
   & ~ JITTER_BIT_MASK(_jitter_bit_no))

/* Expand to an r-value evaluating to the given word with the given number of
   its least significant bits set to the given bits.  No side effects.  This
   does not check that the given new bits fit in the given number of bits.  This
   works by first masking off bits and then applying a bitwise or on the result.
   Rationale: see JITTER_WITH_BITS_MASKED_OFF . */
#define JITTER_WITH_BITS_MASKED_ON(_jitter_word,              \
                                   _jitter_new_bits,          \
                                   _jitter_bit_no)            \
  (JITTER_WITH_BITS_MASKED_OFF(_jitter_word, _jitter_bit_no)  \
   | ((jitter_uint) (_jitter_new_bits)))

/* Expand to an r-value evaluating to the given word arithmetically
   right-shifted by _jitter_bit_no .

   There are basically two separate implementations of this, one relying on >>
   sign-extending on signed operands, like GCC does, and another generic but
   slow solution.  Which implementation is used depends on a constant expression
   checking how >> behaves at compile time.  It might be desirable to move this
   logic to configure.

   Notice that the seemingly obvious alternative of doing a signed division by
   a power of two does not always compute the correct result with a negative
   operand in two's complement: the rounding direction for signed division is
   not what we need here. */
#define JITTER_WITH_BITS_ASHIFTED_OFF(_jitter_word,          \
                                      _jitter_bit_no)        \
  (JITTER_RIGHT_SHIFT_SIGN_EXTENDS                           \
   ? JITTER_WITH_BITS_ASHIFTED_OFF_GCC(_jitter_word,         \
                                       _jitter_bit_no)       \
   : JITTER_WITH_BITS_ASHIFTED_OFF_GENERIC(_jitter_word,     \
                                           _jitter_bit_no))

/* Expand to a constant expression, nonzero iff >> sign-extends (at least on an
   argument of size jitter_int , which is what we care about here).
   This is used in the implementation of JITTER_WITH_BITS_ASHIFTED_OFF . */
#define JITTER_RIGHT_SHIFT_SIGN_EXTENDS                                 \
  /* We rely on one simple test.  Some ridiculous C compiler might */   \
  /* in theory behave in different ways according to the arguments, */  \
  /* but I don't feel pedantic enough to care about this. */            \
  ((((jitter_int) -56) >> 3)                                            \
   == ((jitter_int) -7))

/* One of the two implementations for JITTER_WITH_BITS_ASHIFTED_OFF .  This
   definition is more efficient than the alternative but relies on >>
   sign-extending on signed operands like GCC does; the C standards doesn't
   define a behavior in this case. */
#define JITTER_WITH_BITS_ASHIFTED_OFF_GCC(_jitter_word,    \
                                          _jitter_bit_no)  \
  ((jitter_uint)                                           \
   (((jitter_int) (_jitter_word))                          \
    >> (_jitter_bit_no)))

/* One of the two implementations for JITTER_WITH_BITS_ASHIFTED_OFF .  This
   solution is not pretty and probably very inefficient, with a conditional
   essentially impossible to optimize away and even difficult to compile to
   non-branching code; but at least this doesn't rely on >> performing
   arithmetic right shifts on signed operands. */
#define JITTER_WITH_BITS_ASHIFTED_OFF_GENERIC(_jitter_word,            \
                                              _jitter_bit_no)          \
  (JITTER_MOST_SIGNIFICANT_BIT(_jitter_word)                           \
   ? /* The word is negative: do a logic shift, then or a low bit */   \
     /* mask to the result to set the least significant bits to 1. */  \
     ((((jitter_uint) (_jitter_word))                                  \
       >> (_jitter_bit_no))                                            \
      | JITTER_HIGH_BIT_MASK(_jitter_bit_no))                          \
   : /* The word is non-negative: just do a logic shift. */            \
     (((jitter_uint) (_jitter_word))                                   \
      >> (_jitter_bit_no)))

/* Expand to an r-value evaluating to the given word modified by logically
   right-shifting the value by the given number of bits.  No side effects. */
#define JITTER_WITH_BITS_LSHIFTED_OFF(_jitter_word,     \
                                      _jitter_bit_no)   \
  (((jitter_uint) (_jitter_word)) >> (_jitter_bit_no))

/* Expand to an r-value evaluating to the given word modified by left-shifting
   by the given number of bits and or-ing the given new bits to the result.  No
   side effects.  No check is made to ensure that the new bits actually fit in
   the least significant bit area which was filled with zeroes by shifting. */
#define JITTER_WITH_BITS_SHIFTED_ON(_jitter_word,            \
                                    _jitter_new_bits,        \
                                    _jitter_new_bit_no)      \
  ((((jitter_uint) (_jitter_word)) << (_jitter_new_bit_no))  \
   | (_jitter_new_bits))

/* Expand to an r-value evaluating to the given word with the given new bits
   added.
   Rationale: by adding or removing known tag bits this way it is easy for GCC
   to compile a memory accesse from a tagged base with a known offset into a
   single base-plus-constant-offset load or store: the tag bits get combined
   with the memory offset into a compile-time constant.
   The same trick works for sums or subtractions among unshifted tagged fixnums,
   where some intermediate tagging and untagging operations may be avoided by
   merging them with others. */
#define JITTER_WITH_BITS_ADDED(_jitter_word,  \
                               _jitter_bits)  \
  (((jitter_uint) (_jitter_word))             \
   + ((jitter_uint) (_jitter_bits)))

/* Expand to an r-value evaluating to the given word with the given new bits
   subtracted.
   Rationale: see the comment for JITTER_WITH_BITS_ADDED . */
#define JITTER_WITH_BITS_SUBTRACTED(_jitter_word,  \
                                    _jitter_bits)  \
  (((jitter_uint) (_jitter_word))                  \
   - ((jitter_uint) (_jitter_bits)))

/* Expand to an r-value evaluating to the given number of the least significant
   bits in the given word. */
#define JITTER_GET_BITS(_jitter_word,    \
                        _jitter_bit_no)  \
  (((jitter_uint) (_jitter_word))        \
   & JITTER_BIT_MASK(_jitter_bit_no))

/* Expand to an r-value evaluating to non-false iff the given word has the
   given number of its least significant bits equal to the given value. */
#define JITTER_HAS_BITS(_jitter_word,    \
                        _jitter_bits,    \
                        _jitter_bit_no)  \
  (JITTER_GET_BITS(_jitter_word,         \
                   _jitter_bit_no)       \
   == ((jitter_uint) (_jitter_bits)))




/* Tentative: boxed objects.
 * ************************************************************************** */

/* Assuming the given word evaluates to a boxed tagged object with the given
   tag, expand to an r-value evaluating to an initial pointer to the object
   in-memory representation.  If the type is stage-tagged (see below) the
   pointer will point to the beginning of the header-tagged struct, which is to
   say to the tag header.
   The expression has a char * type and will need to be cast to the appropriate
   type; this macro is meant as a building block for other macros accessing the
   tag header or payload for specific types.  */
#define JITTER_UNBOX_TO_CHAR_STAR(_jitter_word,               \
                                  _jitter_tag,                \
                                  _jitter_tag_bit_no)         \
  ((char *)                                                   \
   (JITTER_WITH_BITS_SUBTRACTED(_jitter_word, _jitter_tag)))

/* Assuming the given word is a boxed object with the given tag, expand to an
   r-value evaluating to an initial pointer to the heap structure, including the
   header tag if any, cast to a pointer to the struct with the given name. */
#define JITTER_UNBOX_TO_STRUCT_STAR(_jitter_word,         \
                                    _jitter_tag,          \
                                    _jitter_tag_bit_no,   \
                                    _jitter_struct_name)  \
  ((struct _jitter_struct_name *)                         \
   (JITTER_UNBOX_TO_CHAR_STAR(_jitter_word,               \
                              _jitter_tag,                \
                              _jitter_tag_bit_no)))




/* Tentative: header tags.
 * ************************************************************************** */

/* FIXME: speak about staging.

   Header-tagged objects are words pointing to
   the beginning of a type-dependent struct with the tag as the first field;
   the pointer itself is tagged with a particular tag called the stage tag. */

/* A header tag is an unsigned word-sized integer.  Objects of types requiring a
   headers are always heap-allocated as structs, of which the first field is a
   header tag named jitter_header_tag .  The actual struct type depends on the
   type, and there may be padding space between the first field and the second;
   however we assume that there is no padding before the first field, so that
   the same header-tag extraction code works for any tagged-header type. */


/* Expand to an identifier, conventionally naming the heap-allocated
   non-tagged-header struct for the named type, using the given C disambiguation
   prefix. */
#define JITTER_NON_TAGGED_HEADER_STRUCT_NAME(_jitter_prefix,     \
                                             _jitter_type_name)  \
  JITTER_CONCATENATE_TWO(_jitter_prefix,                         \
                         _jitter_name)

/* Expand to an identifier, conventionally naming the heap-allocated
   tagged-header struct for the named type, using the given C disambiguation
   prefix.  The payload field of this struct, defined by
   JITTER_DEFINE_TAGGED_HEADER_STRUCT_ , will be of a struct type named
   by JITTER_NON_TAGGED_HEADER_STRUCT_NAME . */
#define JITTER_TAGGED_HEADER_STRUCT_NAME(_jitter_prefix,     \
                                         _jitter_type_name)  \
  JITTER_CONCATENATE_THREE(_jitter_prefix,                   \
                           _tagged_,                         \
                           _jitter_type_name)


/* Expand to a struct definition for a tagged-header struct named
     JITTER_TAGGED_HEADER_STRUCT_NAME(_jitter_prefix,
                                          _jitter_type_name)
   , containing two fields: a tagged header named jitter_header_tag, and a
   member of an untagged struct named
     JITTER_NON_TAGGED_HEADER_STRUCT_NAME(_jitter_prefix,
                                              _jitter_type_name)
   , the member being named jitter_payload . */                         \
#define JITTER_DEFINE_TAGGED_HEADER_STRUCT_(_jitter_prefix,             \
                                            _jitter_type_name)          \
  /* Define a struct containing a header tag and a payload. */          \
  struct JITTER_TAGGED_HEADER_STRUCT_NAME(_jitter_prefix,               \
                                          _jitter_type_name)            \
  {                                                                     \
    /* The header tag.  The header tag is represented as an */          \
    /* untagged unsigned word-sized integer. */                         \
    jitter_uint jitter_header_tag;                                      \
                                                                        \
    /* The actual payload, another struct whose definition is not */    \
    /* machine-generated. */                                            \
    struct JITTER_NON_TAGGED_HEADER_STRUCT_NAME(_jitter_prefix,         \
                                                    _jitter_type_name)  \
    jitter_payload;                                                     \
  };

/* Assumung that _jitter_word evaluates to a stage-tagged object with
   the given stage-tag value and size to a header-tagged object, expand to an
   r-value evaluating to the object header tag. */
#define JITTER_GET_HEADER_TAG(_jitter_word,                    \
                              _jitter_stage_tag,               \
                              _jitter_stage_tag_bit_no)        \
  (* ((jitter_uint *)                                          \
      (JITTER_UNBOX_TO_CHAR_STAR(_jitter_word,                 \
                                 _jitter_stage_tag,            \
                                 _jitter_stage_tag_bit_no))))

/* Assuming that the given word evaluates to a stage-tagged object expand
   to an r-value evaluating to a boolean, non-false iff the header tag has
   the given value.
   This dereferences the pointer, and is therefore unsafe if the object is
   not actually boxed.  JITTER_HAS_HEADER_TAG , below, is a safe version
   of this which also checks the object tag. */
#define JITTER_STAGE_TAGGED_HAS_HEADER_TAG(_jitter_word,              \
                                           _jitter_stage_tag,         \
                                           _jitter_stage_tag_bit_no,  \
                                           _jitter_header_tag)        \
  (JITTER_GET_HEADER_TAG(_jitter_word,                                \
                         _jitter_stage_tag,                           \
                         _jitter_stage_tag_bit_no)                    \
   == (_jitter_header_tag))

/* Expand to an r-value evaluating to a boolean, non-false iff the given word is
   a boxed stage-tagged object with the given stage tag and header tag.
   Notice that several arguments may be evaluated more than once. */
#define JITTER_HAS_HEADER_TAG(_jitter_word,                         \
                              _jitter_stage_tag,                    \
                              _jitter_stage_tag_bit_no,             \
                              _jitter_header_tag)                   \
  (JITTER_HAS_TAG(_jitter_word,                                     \
                  _jitter_stage_tag,                                \
                  _jitter_stage_tag_bit_no)                         \
   && JITTER_STAGE_TAGGED_HAS_HEADER_TAG(_jitter_word,              \
                                         _jitter_stage_tag,         \
                                         _jitter_stage_tag_bit_no,  \
                                         _jitter_header_tag))

/* Expand to an r-value evaluating to an initial pointer to the appropriate
   non-header-tagged structure for the given type, assuming the object is
   actually a non-header-tagged boxed object of the given type. */
#define JITTER_NON_HEADER_TAGGED_PAYLOAD(_jitter_word,        \
                                         _jitter_tag,         \
                                         _jitter_tag_bit_no,  \
                                         _jitter_prefix,      \
                                         _jitter_type_name)   \
  JITTER_UNBOX_TO_STRUCT_STAR(                                \
    _jitter_word,                                             \
    _jitter_tag,                                              \
    _jitter_tag_bit_no,                                       \
    JITTER_NON_TAGGED_HEADER_STRUCT_NAME(_jitter_prefix,      \
                                         _jitter_type_name))

/* Expand to an r-value evaluating to an initial pointer to the appropriate
   header-tagged structure (including the header tag) for the given type,
   assuming the object is actually a header-tagged object of the given type. */
#define JITTER_HEADER_TAGGED_PAYLOAD(_jitter_word,              \
                                     _jitter_stage_tag,         \
                                     _jitter_stage_tag_bit_no,  \
                                     _jitter_prefix,            \
                                     _jitter_type_name)         \
  JITTER_UNBOX_TO_STRUCT_STAR(                                  \
    _jitter_word,                                               \
    _jitter_stage_tag,                                          \
    _jitter_stage_tag_bit_no,                                   \
    JITTER_TAGGED_HEADER_STRUCT_NAME(_jitter_prefix,            \
                                     _jitter_type_name))




/* S-expression representation: tags.
 * ************************************************************************** */

/* I reserve at some of the least bits in every Lisp object, be it boxed or
   unboxed, for its "tag", which contains type information about the object.
   An object tag can be variable-length, as long as it is possible to
   distinguish different cases by looking at a word.  Each case will have both
   a tag configuration and a tag length (in bits).

   Example:
     In a hypothetical system with just three types, integers cons and symbols,
     integers might have the 1-bit tag 0b0, conses the 2-bit tag 0b01 and
     symbols the 2-bit tag 0b11: the integer tag being shorter introduces no
     ambiguity, and makes one more bit available to the object payload.  By
     checking the last three bits on a word we can find its type, with
     conditionals or a table lookup.

   An object tag contains some type information about the object, but not
   necessarily all of it.  If the number of types in the system is too high to
   be encoded using just tag then one tag configuration and length is reserved
   as the "stage tag".  An object whose tag is the stage tag is always boxed,
   and encodes a pointer to a struct whose first field is a word-sized "header
   tag", followed by type-dependent data.  Not all unboxed objects are
   header-tagged: for efficiency reasons some boxed types which are very
   frequently used, such as conses in Lisp, may have a tag which is sufficient
   to identify the object type alone, and in that case the memory representation
   of the object will have no header tag.

   Example:
     Another hypothetical system might have fixnums, symbols, the empty list,
     conses, vectors and strings.  Lists are commonly used and their efficiency
     is paramount, so we don't want conses to have a header tag and we want the
     empty list to be unique and unboxed.
     A reasonable tag assignment for this system would be:
     - 2-bit: 0b00 for fixnums, unboxed;
     - 2-bit: 0b01 for the empty list, unboxed;
     - 2-bit: 0b10 for conses, boxed, no header tag;
     - 2-bit: 0b11 as the stage tag.
     Symbols, vectors and strings will be stage-tagged, and their header tag
     will contain three different values in order to distinguish each type from
     the other two.  Notice that symbols can still be compared by identity
     without touching memory: the tagged object points to a struct containing
     the symbol attributes, not to another pointer; if symbols are interned then
     tagged objects for equal symbols will be equal. */




/* S-expression representation: tag checking, tagging and untagging.
 * ************************************************************************** */

/* An C object of the appropriate type can be "encoded" into a Jitter
   object by representing it, or some pointer to it or to equivalent
   information in memory, combined with a tag.  "Decoding" is the opposite
   process converting a Jitter object to a C object, or a pointer to it.

   Encoding and decoding are non-destructive operations: they expand to
   expressions evaluating to values, and do not modify the result of their
   operand evaluation.  Memory allocation is a separate operation from encoding
   and decoding; memory operations are defined in jitter-allocator.h ,
   not here. */

/* Style/mnemonic convention: these macros have arguments always following
   this order:
   - object;
   - tag;
   - tag-bit-no.
   The general-purpose macros for tagging and untagging objects, meant to be
   used for defining type-specific tagging and untagging, take all of the
   arguments above, in the order above, even if some unneeded arguments may
   never be evaluated.  This makes the code easier to modify. */

/* Expand to a r-value evaluating to a boolean, non-false iff the given word has
   the given tag. */
#define JITTER_HAS_TAG(_jitter_tagged_object,  \
                       _jitter_tag,            \
                       _jitter_tag_bit_no)     \
  (((_jitter_tagged_object)                    \
    & JITTER_BIT_MASK(_jitter_tag_bit_no))     \
   == (_jitter_tag))

/* Expand to an r-value evaluating to the Lisp representation of the given
   object, which must have a type castable to jitter_uint, on which the given
   tag is attached by left-shiting and or-ing. */
#define JITTER_WITH_TAG_SHIFTED_ON(_jitter_untagged_object,  \
                                   _jitter_tag,              \
                                   _jitter_tag_bit_no)       \
  JITTER_WITH_BITS_SHIFTED_ON(                               \
     _jitter_untagged_object,                                \
     _jitter_tag,                                            \
     _jitter_tag_bit_no)

/* Expand to an r-value evaluating to the given object representation modified
   by arithmetically shifting the value right, eliminating tag bits.  No side
   effects. */
#define JITTER_WITH_TAG_ASHIFTED_OFF(_jitter_tagged_object,  \
                                     _jitter_tag,            \
                                     _jitter_tag_bit_no)     \
  JITTER_WITH_BITS_ASHIFTED_OFF(                             \
     _jitter_tagged_object,                                  \
     _jitter_tag_bit_no)

/* Expand to an r-value evaluating to the given object representation modified
   by logically shifting the value right, eliminating tag bits.  No side
   effects. */
#define JITTER_WITH_TAG_LSHIFTED_OFF(_jitter_tagged_object,  \
                                     _jitter_tag,            \
                                     _jitter_tag_bit_no)     \
  JITTER_WITH_BITS_LSHIFTED_OFF(                             \
     _jitter_tagged_object,                                  \
     _jitter_tag_bit_no)

/* Expand to an r-value evaluating to the Lisp representation of the given
   object, which must have a type castable to jitter_uint, on which the given
   tag is attached by masking-shiting and or-ing -- which is to say,
   by overwriting the rightmost _jitter_tag_bit_no bits of the
   untagged representation but without losing any bit of the left.

   Rationale: see the comment before JITTER_WITH_TAG_MASKED_OFF. */
#define JITTER_WITH_TAG_MASKED_ON(_jitter_untagged_object,  \
                                  _jitter_tag,              \
                                  _jitter_tag_bit_no)       \
  JITTER_WITH_BITS_MASKED_ON(                               \
     _jitter_untagged_object,                               \
     _jitter_tag,                                           \
     _jitter_tag_bit_no)

/* Expand to an r-value evaluating to the given object representation modified
   by seeting all the tag bits to zero.  The object payload may or may not need
   to be shifted according to its type, but that operation is not performed by
   the expansion of this macro.  No side effects.
   Rationale: see JITTER_WITH_BITS_MASKED_OFF . */
#define JITTER_WITH_TAG_MASKED_OFF(_jitter_untagged_object,  \
                                   _jitter_tag,              \
                                   _jitter_tag_bit_no)       \
  JITTER_WITH_BITS_MASKED_OFF(                               \
     _jitter_tagged_object,                                  \
     _jitter_tag_bit_no)

/* Expand to an r-value evaluating to the Lisp representation of the given
   object, which must have a type castable to jitter_uint, on which the given
   tag is attached by simply adding it -- this assumes that the rightmost
   JITTER_TAG_BIT_NO bits of the untagged representation are zero, and does
   *not* check that it's true. */
#define JITTER_WITH_TAG_ADDED(_jitter_untagged_object,  \
                              _jitter_tag,              \
                              _jitter_tag_bit_no)       \
  JITTER_WITH_BITS_ADDED(_jitter_untagged_object,       \
                         _jitter_tag)

/* Expand to an r-value evaluating to the given object representation modified
   by seeting all the tag bits to zero via a subtraction; this assumes that the
   encoded object has the provided tag, which is *not* checked.  The object
   payload may or may not need to be shifted, according to its type; this macro
   expansion does not do that.  No side effects.

   Rationale: when loading or storing thru tagged pointers, particularly if the
   offset is a compile-time constant, the tag to be subtracted can be combined
   with the offset; this saves one bitwise and instruction. */
#define JITTER_WITH_TAG_SUBTRACTED(_jitter_tagged_object,  \
                                   _jitter_tag,            \
                                   _jitter_tag_bit_no)     \
  JITTER_WITH_BITS_SUBTRACTED(_jitter_tagged_object,       \
                              _jitter_tag)




// FIXME: split the file here.///////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/* About this file.
 * ************************************************************************** */

/* This header provides macro definitions for encoding and decoding
   s-expressions, which is to say for converting from a C object to the tagged
   Lisp representation of the same object, and vice-versa.

   Allocation and memory handling is *not* covered here: see
   jitterlisp-allocator.h .  Operations on Lisp objects are not defined here
   either: see jitterlisp-operations.h . */




/* S-expression representation.
 * ************************************************************************** */

/* A JitterLisp object is a tagged object. */
typedef jitter_tagged_object jitterlisp_object;




/* S-expression representation: conventions.
 * ************************************************************************** */

/* Some operations on s-expression are more efficient with specific stag
   values.  When the definitions below need to make such assumptions they always
   do it within CPP conditionals checking for the actual value.

   Stag values and widths must be kept easy to change in the future, even
   conditionally to accommodate for different hardware.

   Operations on tagged objects are not defined here: see
   jitterlisp-operations.h . */

/* For every tagged type foo the following macros are defined:
   - the tag size in bits for foos, named JITTERLISP_FOO_TAG_BIT_NO;
   - the tag for foos, named JITTERLISP_FOO_TAG;
   - the untagged C type for foos, named JITTERLISP_FOO_UNTAGGED_TYPE;
   - the macro JITTERLISP_FOO_ENCODE(untagged_exp), expanding to an r-value
     evaluating to the tagged representation of the result of the evaluation
     of untagged_exp as a foo;
   - the macro JITTERLISP_FOO_DECODE(tagged_exp), expanding to an r-value
     evaluating to the untagged representation of the result of the evaluation
     of tagged_exp, as a JITTERLISP_FOO_UNTAGGED_TYPE.
   - the macro JITTERLISP_IS_FOO(tagged_exp), expanding to an r-value which
     evaluates to a C boolean, non-false iff the tagged expression has type
     foo. */




/* S-expression representation: dummy "anything" type.
 * ************************************************************************** */

/* This dummy tag check succeeds with any object.  It is convenient to have for
   machine-generated code containing a tag-checking macro, which sometimes need
   no actual check. */
#define JITTERLISP_IS_ANYTHING(_jitterlisp_tagged_object)  \
  true




/* S-expression representation: fixnums.
 * ************************************************************************** */

/* Fixnums are encoded unboxed as two's complement signed integers. */

/* The tag for fixnums.  Notice that a zero tag allows for more efficient sum
   and subtraction operations, and this is exploited in the operation
   definitions. */
#define JITTERLISP_FIXNUM_TAG_BIT_NO    4
#define JITTERLISP_FIXNUM_TAG           0b0000

/* The C type for untagged fixnums.  Notice that fixnums are always signed. */
#define JITTERLISP_FIXNUM_UNTAGGED_TYPE  jitter_int

/* Expand to an r-value evaluating to a C (untagged) boolean which is non-false
   iff the given tagged object evaluates to a fixnum. */
#define JITTERLISP_IS_FIXNUM(_jitterlisp_tagged_object)  \
  JITTER_HAS_TAG((_jitterlisp_tagged_object),            \
                 JITTERLISP_FIXNUM_TAG,                  \
                 JITTERLISP_FIXNUM_TAG_BIT_NO)

/* Expand to an r-value evaluating to the encoded representation of the given
   untagged integer expression as a Lisp fixnum. */
#define JITTERLISP_FIXNUM_ENCODE(_jitterlisp_untagged_fixnum)  \
  JITTER_WITH_TAG_SHIFTED_ON((_jitterlisp_untagged_fixnum),    \
                             JITTERLISP_FIXNUM_TAG,            \
                             JITTERLISP_FIXNUM_TAG_BIT_NO)

/* Expand to an r-value evaluating to the untagged jitter_int content of the
   given tagged fixnum.  No type check is performed. */
#define JITTERLISP_FIXNUM_DECODE(_jitterlisp_tagged_fixnum)   \
  JITTER_WITH_TAG_ASHIFTED_OFF(_jitterlisp_tagged_fixnum,     \
                               JITTERLISP_FIXNUM_TAG,         \
                               JITTERLISP_FIXNUM_TAG_BIT_NO)




/* S-expression representation: unique and character values.
 * ************************************************************************** */

/* Unique Lisp types populated by a single object such as (), #t and #f only need
   very few bits to represent, so can use a longer stag with a suffix to be shared
   with another type whose elements are relatively few in number.  A good candidate
   for such a type is the character type.  Distinct characters are only about one
   million in Unicode and therefore can be easily represented unboxed along with
   every unique object.

   I prefer to assume a wide fixed-width encoding for characters in memory, such
   as UCF-4; however using single UTF-8 bytes as characters works as well; each
   one will be considered an object of its own.

   This is still quite wasteful in terms of the actual bit configuration used
   in the space of the possible configurations.  Some other type might fit
   here in the future, with just one more stag bit to discriminate. */

/* How to distinguish unique values from characters. */
#define JITTERLISP_UNIQUE_TAG_BIT_NO               5
#define JITTERLISP_UNIQUE_TAG                      0b01000
#define JITTERLISP_CHARACTER_TAG_BIT_NO            5
#define JITTERLISP_CHARACTER_TAG                   0b11000

/* Expand to an r-value evaluating to a C (untagged) boolean which is non-false
   iff the given tagged object evaluates to a unique object. */
#define JITTERLISP_IS_UNIQUE(_jitterlisp_tagged_object)  \
  JITTER_HAS_TAG((_jitterlisp_tagged_object),            \
                 JITTERLISP_UNIQUE_TAG,                  \
                 JITTERLISP_UNIQUE_TAG_BIT_NO)

/* Like JITTERLISP_IS_UNIQUE , for characters. */
#define JITTERLISP_IS_CHARACTER(_jitterlisp_tagged_object)  \
  JITTER_HAS_TAG((_jitterlisp_tagged_object),               \
                 JITTERLISP_CHARACTER_TAG,                  \
                 JITTERLISP_CHARACTER_TAG_BIT_NO)

/* Encode operation for a character. */
#define JITTERLISP_CHARACTER_ENCODE(_jitterlisp_untagged_character)  \
  JITTER_WITH_TAG_SHIFTED_ON((_jitterlisp_untagged_character),       \
                             JITTERLISP_CHARACTER_TAG,               \
                             JITTERLISP_CHARACTER_TAG_BIT_NO)

/* Encode operation for a unique-object index. */
#define JITTERLISP_UNIQUE_ENCODE(_jitterlisp_unique_index)  \
  JITTER_WITH_TAG_SHIFTED_ON((_jitterlisp_unique_index),    \
                             JITTERLISP_UNIQUE_TAG,         \
                             JITTERLISP_UNIQUE_TAG_BIT_NO)

/* Decode operation for a character. */
#define JITTERLISP_UNIQUE_DECODE(_jitterlisp_tagged_object)   \
  JITTER_WITH_TAG_LSHIFTED_OFF((_jitterlisp_tagged_object),   \
                               JITTERLISP_UNIQUE_TAG,         \
                               JITTERLISP_UNIQUE_TAG_BIT_NO)

/* Decode operation for a unique-object index. */
#define JITTERLISP_CHARACTER_DECODE(_jitterlisp_tagged_object)   \
  JITTER_WITH_TAG_LSHIFTED_OFF((_jitterlisp_tagged_object),      \
                               JITTERLISP_CHARACTER_TAG,         \
                               JITTERLISP_CHARACTER_TAG_BIT_NO)

/* Every unique object has a unique printable name.  The array is meant to be
   indexed by decoded unique values and is defined to have exactly
   JITTERLISP_UNIQUE_OBJECT_NO elements. */
extern const char * const
jitterlisp_unique_object_names [];




/* S-expression representation: specific unique objects.
 * ************************************************************************** */

/* Unique objects are simple unboxed objects, each represented as a shifted
   index.  They are efficient to compare to, but by themselves hold no mutable
   state and no attributes. */

/* How many unique objects there are.  This of course must agree with the
   definitions below. */
#define JITTERLISP_UNIQUE_OBJECT_NO  6

/* Define every unique object.  The names in the definition of
   jitterlisp_unique_object_names must follow this order. */

/* The #f object.  In JitterLisp this is distinct from () and the symbol named
   nil, which is a symbol like any other. */
#define JITTERLISP_FALSE       JITTERLISP_UNIQUE_ENCODE(0)

/* The #t object. */
#define JITTERLISP_TRUE        JITTERLISP_UNIQUE_ENCODE(1)

/* The () object.  In JitterLisp this is distinct from #f and the symbol named
   nil, which is a symbol like any other. */
#define JITTERLISP_EMPTY_LIST  JITTERLISP_UNIQUE_ENCODE(2)

/* The end-of-file or end-of-input object.  This object has no reader syntax. */
#define JITTERLISP_EOF         JITTERLISP_UNIQUE_ENCODE(3)

/* A unique object conventionally used as the result of forms not evaluating to
   any useful result.  No reader syntax. */
#define JITTERLISP_NOTHING     JITTERLISP_UNIQUE_ENCODE(4)

/* A unique object used to represent the global value of globally unbound or
   temporarily undefined variables, for example in the expansion of letrec .
   This is used in the internal representation but should never be the result of
   a correct evaluation.  No reader syntax. */
#define JITTERLISP_UNDEFINED   JITTERLISP_UNIQUE_ENCODE(5)

/* Unique object predicates.  Since unique objects are unboxed (and unique)
   these are simple comparisons by identity.  The expansion evaluates to a
   C (untagged) boolean r-value. */
#define JITTERLISP_IS_EMPTY_LIST(_jitterlisp_tagged_object)  \
  ((_jitterlisp_tagged_object) == JITTERLISP_EMPTY_LIST)
#define JITTERLISP_IS_TRUE(_jitterlisp_tagged_object)  \
  ((_jitterlisp_tagged_object) == JITTERLISP_TRUE)
#define JITTERLISP_IS_FALSE(_jitterlisp_tagged_object)  \
  ((_jitterlisp_tagged_object) == JITTERLISP_FALSE)
#define JITTERLISP_IS_EOF(_jitterlisp_tagged_object)  \
  ((_jitterlisp_tagged_object) == JITTERLISP_EOF)
#define JITTERLISP_IS_NOTHING(_jitterlisp_tagged_object)  \
  ((_jitterlisp_tagged_object) == JITTERLISP_NOTHING)
#define JITTERLISP_IS_UNDEFINED(_jitterlisp_tagged_object)  \
  ((_jitterlisp_tagged_object) == JITTERLISP_UNDEFINED)




/* S-expression representation: Booleans.
 * ************************************************************************** */

/* The Boolean constants JITTERLISP_FALSE and JITTERLISP_TRUE are unique values
   like any other, already defined above.  Booleans are not a separate "type"
   in the sense of tags or even extended tags, but it is convenient for the user
   to see them that way.  The following convenience macros provide the
   illusion. */

/* Expand to an r-value (untagged) boolean evaluating to non-false iff the
   given tagged object is #t or #f . */
#define JITTERLISP_IS_BOOLEAN(_jitterlisp_tagged_object)  \
  (JITTERLISP_IS_TRUE(_jitterlisp_tagged_object)          \
   || JITTERLISP_IS_FALSE(_jitterlisp_tagged_object))

/* Expand to an r-value evaluating to a tagged boolean value, true iff the given
   argument evalutes to non-false.

   This is difficult to make always efficient without requiring C's booleans to
   be canonical, but should not be very critical.  The conditional expression
   should always be easy for GCC to optimize away when the encoded value is the
   result of a C comparison accessible to the compiler rather than coming, for
   example, from a function argument. */
#define JITTERLISP_BOOLEAN_ENCODE(_jitterlisp_untagged_bool)          \
  ((_jitterlisp_untagged_bool) ? JITTERLISP_TRUE : JITTERLISP_FALSE)

/* Expand to an r-value evaluating to a C (untagged) boolean value, false
   iff the argument evaluates to the false boolean tagged value.  This is
   the preferred way of checking a JitterLisp object for falsity. */
#define JITTERLISP_BOOLEAN_DECODE(_jitterlisp_tagged_bool)  \
  ((_jitterlisp_tagged_bool) != JITTERLISP_FALSE)




/* S-expression representation: symbols.
 * ************************************************************************** */

/* Symbols are handled in a special way allocation-wise: interned symbols are
   allocated with malloc, and live until the memory subsystem is finalized.
   Uninterned symbols, on the other hand, live on the garbage-collected heap.

   Both symbol types are encoded pointers to a struct jitterlisp_symbol . */
#define JITTERLISP_SYMBOL_TAG_BIT_NO  3
#define JITTERLISP_SYMBOL_TAG         0b001

/* A symbol datum. */
struct jitterlisp_symbol
{
  /* The symbol name as a malloc-allocated string, or NULL if the symbol is not
     interned. */
  char *name_or_NULL;

  /* The value bound to the symbol in the global environment, or
     JITTERLISP_UNDEFINED if there is no global binding.

     FIXME: this makes each symbol a GC root which will require some careful
     testing in the case of interned symbols, as they are malloc-allocated. */
  jitterlisp_object global_value;
};

/* Symbol tag checking, encoding and decoding. */
#define JITTERLISP_IS_SYMBOL(_jitterlisp_tagged_object)  \
  JITTER_HAS_TAG((_jitterlisp_tagged_object),            \
                 JITTERLISP_SYMBOL_TAG,                  \
                 JITTERLISP_SYMBOL_TAG_BIT_NO)
#define JITTERLISP_SYMBOL_ENCODE(_jitterlisp_untagged_symbol)  \
  JITTER_WITH_TAG_ADDED(_jitterlisp_untagged_symbol,           \
                        JITTERLISP_SYMBOL_TAG,                 \
                        JITTERLISP_SYMBOL_TAG_BIT_NO)
#define JITTERLISP_SYMBOL_DECODE(_jitterlisp_tagged_symbol)     \
  ((struct jitterlisp_symbol *)                                 \
   (JITTER_WITH_TAG_SUBTRACTED((_jitterlisp_tagged_symbol),     \
                               JITTERLISP_SYMBOL_TAG,           \
                               JITTERLISP_SYMBOL_TAG_BIT_NO)))




/* S-expression representation: conses.
 * ************************************************************************** */

/* Conses are represented boxed, with no header.  Accessing the car and cdr
   fields in memory is a frequent operation so it's particularly important to
   decode tagged conses with subtractions, which are often optimizable. */

#define JITTERLISP_CONS_TAG_BIT_NO    3
#define JITTERLISP_CONS_TAG           0b010

/* A cons datum. */
struct jitterlisp_cons
{
  /* The first cons field. */
  jitterlisp_object car;

  /* The second cons field. */
  jitterlisp_object cdr;
};

/* Cons tag checking, encoding and decoding. */
#define JITTERLISP_IS_CONS(_jitterlisp_tagged_object)  \
  JITTER_HAS_TAG((_jitterlisp_tagged_object),          \
                 JITTERLISP_CONS_TAG,                  \
                 JITTERLISP_CONS_TAG_BIT_NO)
#define JITTERLISP_CONS_ENCODE(_jitterlisp_untagged_cons)  \
  JITTER_WITH_TAG_ADDED(_jitterlisp_untagged_cons,         \
                        JITTERLISP_CONS_TAG,               \
                        JITTERLISP_CONS_TAG_BIT_NO)
#define JITTERLISP_CONS_DECODE(_jitterlisp_tagged_cons)       \
  ((struct jitterlisp_cons *)                                 \
   (JITTER_WITH_TAG_SUBTRACTED((_jitterlisp_tagged_cons),     \
                               JITTERLISP_CONS_TAG,           \
                               JITTERLISP_CONS_TAG_BIT_NO)))



/* S-expression representation: closures.
 * ************************************************************************** */

/* Closures are represented boxed, with no header. */

#define JITTERLISP_CLOSURE_TAG_BIT_NO    3
#define JITTERLISP_CLOSURE_TAG           0b011

/* A closure datum. */
struct jitterlisp_closure
{
  /* The non-global environment, as an a-list. */
  jitterlisp_object environment;

  /* The procedure formal arguments as a list of distinct symbols. */
  jitterlisp_object formals;

  /* The procedure body as an AST. */
  jitterlisp_object body;
};

/* Closure tag checking, encoding and decoding. */
#define JITTERLISP_IS_CLOSURE(_jitterlisp_tagged_object)  \
  JITTER_HAS_TAG((_jitterlisp_tagged_object),             \
                 JITTERLISP_CLOSURE_TAG,                  \
                 JITTERLISP_CLOSURE_TAG_BIT_NO)
#define JITTERLISP_CLOSURE_ENCODE(_jitterlisp_untagged_closure)  \
  JITTER_WITH_TAG_ADDED(_jitterlisp_untagged_closure,            \
                        JITTERLISP_CLOSURE_TAG,                  \
                        JITTERLISP_CLOSURE_TAG_BIT_NO)
#define JITTERLISP_CLOSURE_DECODE(_jitterlisp_tagged_closure)    \
  ((struct jitterlisp_closure *)                                 \
   (JITTER_WITH_TAG_SUBTRACTED((_jitterlisp_tagged_closure),     \
                               JITTERLISP_CLOSURE_TAG,           \
                               JITTERLISP_CLOSURE_TAG_BIT_NO)))




/* S-expression representation: primitives.
 * ************************************************************************** */

/* Primitives are represented boxed. */

#define JITTERLISP_PRIMITIVE_TAG_BIT_NO    3
#define JITTERLISP_PRIMITIVE_TAG           0b100

/* How many arguments a primitive can take, as a maximum. */
#define JITTERLISP_PRIMITIVE_MAX_IN_ARITY   4

/* Primitives are call-by-value (therefore they all behave as procedures: if and
   or , for example, cannot be primitives) and have a fixed in-arity, which in
   interpreted code must be checked at call time.  Primitives, like procedures,
   always return exactly one result, which may be #<nothing> . */

/* A primitive C function takes as its only argument an initial pointer to a C
   array of already evaluated actual arguments, and returns the result which is
   always exactly one.  The primitive function checks the actual argument types
   (when needed), but not their number. */
typedef jitterlisp_object (*jitterlisp_primitive_function)
(const jitterlisp_object *evaluated_actuals);

/* A primitive descriptor, used for both primitive procedures and primitive
   macros.  Primitives descriptors are all global constants and don't live on
   the garbage-collected heap.  They don't need to be GC roots as they don't
   point to other Lisp objects. */
struct jitterlisp_primitive
{
  /* The primitive Lisp name as a C string. */
  char *name;

  /* How many arguments the primitive takes. */
  jitter_uint in_arity;

  /* Non-false iff the descriptor is for a primitive procedure rather than a
     primitive macro. */
  bool procedure;

  /* A C function implementing the primitive procedure or primitive macro. */
  jitterlisp_primitive_function function;
};

/* Primitive tag checking, encoding and decoding. */
#define JITTERLISP_IS_PRIMITIVE(_jitterlisp_tagged_object)  \
  JITTER_HAS_TAG((_jitterlisp_tagged_object),               \
                 JITTERLISP_PRIMITIVE_TAG,                  \
                 JITTERLISP_PRIMITIVE_TAG_BIT_NO)
#define JITTERLISP_PRIMITIVE_ENCODE(_jitterlisp_untagged_primitive)  \
  JITTER_WITH_TAG_ADDED(_jitterlisp_untagged_primitive,              \
                        JITTERLISP_PRIMITIVE_TAG,                    \
                        JITTERLISP_PRIMITIVE_TAG_BIT_NO)
#define JITTERLISP_PRIMITIVE_DECODE(_jitterlisp_tagged_primitive)  \
  ((struct jitterlisp_primitive *)                                 \
   (JITTER_WITH_TAG_SUBTRACTED((_jitterlisp_tagged_primitive),     \
                               JITTERLISP_PRIMITIVE_TAG,           \
                               JITTERLISP_PRIMITIVE_TAG_BIT_NO)))




/* S-expression representation: procedures.
 * ************************************************************************** */

/* "Procedures" don't exist as objects with a tag of their own: a procedure is
   either a closure or a primitive.  Of course they are implemented differently
   but from the user's point of view they are interchangeable, which is why
   this type checking is useful. */
#define JITTERLISP_IS_PROCEDURE(_jitterlisp_tagged_object)  \
  (JITTERLISP_IS_CLOSURE(_jitterlisp_tagged_object)         \
   || JITTERLISP_IS_PRIMITIVE(_jitterlisp_tagged_object))




/* S-expression representation: vectors.
 * ************************************************************************** */

/* Vectors are represented boxed as a header pointing to the actual vector
   elements as a separate heap buffer, not directly accessible by the user. */

#define JITTERLISP_VECTOR_TAG_BIT_NO    3 // disabled: see below.
#define JITTERLISP_VECTOR_TAG           0b100 // disabled: see below.

// FIXME: vectors are currently disabled, until I implement object headers.

/* A vector header. */
struct jitterlisp_vector
{
  /* How many elements there are. */
  jitter_uint element_no;

  /* A pointer to the first element. */
  jitterlisp_object *elements;
};

// FIXME: vectors are currently disabled, until I implement object headers.

/* Vector tag checking, encoding and decoding. */
/* #define JITTERLISP_IS_VECTOR(_jitterlisp_tagged_object)  \ */
/*   JITTER_HAS_TAG((_jitterlisp_tagged_object),        \ */
/*                      JITTERLISP_VECTOR_TAG,             \ */
/*                      JITTERLISP_VECTOR_TAG_BIT_NO) */
#define JITTERLISP_IS_VECTOR(_jitterlisp_tagged_object)  \
  false
#define JITTERLISP_VECTOR_ENCODE(_jitterlisp_untagged_vector)  \
  JITTER_WITH_TAG_ADDED(_jitterlisp_untagged_vector,           \
                        JITTERLISP_VECTOR_TAG,                 \
                        JITTERLISP_VECTOR_TAG_BIT_NO)
#define JITTERLISP_VECTOR_DECODE(_jitterlisp_tagged_vector)     \
  ((struct jitterlisp_vector *)                                 \
   (JITTER_WITH_TAG_SUBTRACTED((_jitterlisp_tagged_vector),     \
                               JITTERLISP_VECTOR_TAG,           \
                               JITTERLISP_VECTOR_TAG_BIT_NO)))




/* [FIXME: tentative] Non-primitive macros.
 * ************************************************************************** */

/* Non-primitive (low-level) macros are implemented exactly like closures using
   struct jitterlisp_closure , with a different tag. */

#define JITTERLISP_NON_PRIMITIVE_MACRO_TAG_BIT_NO    3
#define JITTERLISP_NON_PRIMITIVE_MACRO_TAG           0b101


/* Non-primitive-macro tag checking, encoding and decoding. */
#define JITTERLISP_IS_NON_PRIMITIVE_MACRO(_jitterlisp_tagged_object)  \
  JITTER_HAS_TAG((_jitterlisp_tagged_object),                         \
                 JITTERLISP_NON_PRIMITIVE_MACRO_TAG,                  \
                 JITTERLISP_NON_PRIMITIVE_MACRO_TAG_BIT_NO)
#define JITTERLISP_NON_PRIMITIVE_MACRO_ENCODE(_jitterlisp_untagged_non_primitive_macro)  \
  JITTER_WITH_TAG_ADDED(_jitterlisp_untagged_non_primitive_macro,                        \
                        JITTERLISP_NON_PRIMITIVE_MACRO_TAG,                              \
                        JITTERLISP_NON_PRIMITIVE_MACRO_TAG_BIT_NO)
#define JITTERLISP_NON_PRIMITIVE_MACRO_DECODE(_jitterlisp_tagged_non_primitive_macro)  \
  ((struct jitterlisp_closure *)                                                       \
   (JITTER_WITH_TAG_SUBTRACTED((_jitterlisp_tagged_non_primitive_macro),               \
                               JITTERLISP_NON_PRIMITIVE_MACRO_TAG,                     \
                               JITTERLISP_NON_PRIMITIVE_MACRO_TAG_BIT_NO)))



/* [FIXME: tentative] Primitive macros.
 * ************************************************************************** */

/* Primitive macros are implemented exactly like primitives using struct
   jitterlisp_primitive , with a different tag. */

#define JITTERLISP_PRIMITIVE_MACRO_TAG_BIT_NO    3
#define JITTERLISP_PRIMITIVE_MACRO_TAG           0b110

/* Primitive-macro tag checking, encoding and decoding. */
#define JITTERLISP_IS_PRIMITIVE_MACRO(_jitterlisp_tagged_object)  \
  JITTER_HAS_TAG((_jitterlisp_tagged_object),                     \
                 JITTERLISP_PRIMITIVE_MACRO_TAG,                  \
                 JITTERLISP_PRIMITIVE_MACRO_TAG_BIT_NO)
#define JITTERLISP_PRIMITIVE_MACRO_ENCODE(_jitterlisp_untagged_primitive_macro)  \
  JITTER_WITH_TAG_ADDED(_jitterlisp_untagged_primitive_macro,                    \
                        JITTERLISP_PRIMITIVE_MACRO_TAG,                          \
                        JITTERLISP_PRIMITIVE_MACRO_TAG_BIT_NO)
#define JITTERLISP_PRIMITIVE_MACRO_DECODE(_jitterlisp_tagged_primitive_macro)  \
  ((struct jitterlisp_primitive *)                                             \
   (JITTER_WITH_TAG_SUBTRACTED((_jitterlisp_tagged_primitive_macro),           \
                               JITTERLISP_PRIMITIVE_MACRO_TAG,                 \
                               JITTERLISP_PRIMITIVE_MACRO_TAG_BIT_NO)))




/* [FIXME: tentative] Macros.
 * ************************************************************************** */

/* A macro is either a primitive macro or a non-primitive macro. */
#define JITTERLISP_IS_MACRO(_jitterlisp_tagged_object)               \
  (JITTERLISP_IS_PRIMITIVE_MACRO(_jitterlisp_tagged_object)          \
   || JITTERLISP_IS_NON_PRIMITIVE_MACRO(_jitterlisp_tagged_object))




/* S-expression representation: ASTs.
 * ************************************************************************** */

// FIXME: support "extended" types sharing tags at the cost of having a header.

#define JITTERLISP_AST_TAG_BIT_NO    3
#define JITTERLISP_AST_TAG           0b111

/* Just a declaration for the AST data structure.  Its definition is in
   jitterlisp-ast.h . */
struct jitterlisp_ast;

/* AST tag checking, encoding and decoding. */
#define JITTERLISP_IS_AST(_jitterlisp_tagged_object)  \
  JITTER_HAS_TAG(_jitterlisp_tagged_object,           \
                 JITTERLISP_AST_TAG,                  \
                 JITTERLISP_AST_TAG_BIT_NO)
#define JITTERLISP_AST_ENCODE(_jitterlisp_untagged_AST)  \
  JITTER_WITH_TAG_ADDED(_jitterlisp_untagged_AST,        \
                        JITTERLISP_AST_TAG,              \
                        JITTERLISP_AST_TAG_BIT_NO)
#define JITTERLISP_AST_DECODE(_jitterlisp_tagged_AST)        \
  ((struct jitterlisp_ast *)                                 \
   (JITTER_WITH_TAG_SUBTRACTED((_jitterlisp_tagged_AST),     \
                               JITTERLISP_AST_TAG,           \
                               JITTERLISP_AST_TAG_BIT_NO)))




/* Alignment requirement.
 * ************************************************************************** */

/* In order to represent tags we need this number of low-order bits to be
   zero in initial heap pointers. */
#define JITTERLISP_INITIAL_POINTER_ZERO_BIT_NO  3




/* Globally named objects.
 * ************************************************************************** */

/* A few s-expressions, particularly some interned symbols, are important enough
   for performance reasons to be bound to global C variables.  It would be nice
   to make them constant, but this is not possible since most of them require
   heap-allocation.

   This requires them to be GC roots, which will need some work if I switch to a
   moving GC. */
extern jitterlisp_object jitterlisp_low_level_macro_args;




/* Not for the user: s-expression initialization and finalization.
 * ************************************************************************** */

/* These functions are called by jitterlisp_initialize and jitterlisp_finalize
   as needed.  They are not for the user to call directly. */

/* Initialize the s-expression subsystem.  This must be called before using any
   other function declared here. */
void
jitterlisp_sexpression_initialize (void);

/* Finalize the s-expression subsystem and free resources.  After this is called
   no other function declared here may be used again, until the subsystem is
   re-initialized with jitterlisp_sexpression_initialize. */
void
jitterlisp_sexpression_finalize (void);

#endif // #ifndef JITTERLISP_SEXPRESSION_H_
