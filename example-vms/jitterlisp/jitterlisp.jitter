## Jitter specification for the JitterLisp VM.

## Copyright (C) 2017, 2018 Luca Saiu
## Written by Luca Saiu

## This file is part of the Jittery Lisp language implementation, distributed as
## an example along with Jitter under the same license.

## Jitter is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.

## Jitter is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.

## You should have received a copy of the GNU General Public License
## along with Jitter.  If not, see <http://www.gnu.org/licenses/>.


## Global configuration.
#################################################################

vm
  set prefix "jitterlispvm"
  tos-stack "jitterlisp_object" "mainstack"

  # FIXME: the return stack might need a different type.  Or not.
  ntos-stack "jitterlisp_object" "returnstack"
end




## Register classes.
#################################################################

# We only need one register class.
register-class r 5
  code
    jitterlisp_object
  end
end




## Functions and globals to wrap.
#################################################################

wrapped-functions
  # Libc cunctions which may be implicitly called by compiled code, for
  # example when passing parameters.
# FIXME: no, GCC is not stupid and generates these directly in its
# intermediate representation.  The hack doesn't work here.

  # Temporary/debugging stuff.
  debug_pointer
  log_
  putchar
#  printf
  jitterlisp_print_to_stream
  dump_stacks
  jitter_log_instruction

  # Calling interpreted closures from compiled code.
  jitterlisp_call_interpreted

  # These are needed in operations, as per jitterlisp-operations.h .  Only
  # the functions we call *directly* thru instructions need to be wrapped:
  # low-priority primitives, not worth optimizing, are all called via the
  # "primitive" VM instruction which invokes a function pointer given as an
  # instruction argument.
  # (None yet.)
  # [FIXME: I'll need some function related to eval, to call interpreted
  # code from VM code]

  # Some primitives, notably cons , allocate heap memory from VM instructions.
  jitterlisp_allocate

  # Erroring out from instructions.
  jitterlisp_fail_from_vm
  jitterlispvm_error_invalid_primitive_argument_type_unfriendly
  jitterlispvm_error_invalid_primitive_argument_type_friendly
end

wrapped-globals
  stack_printf_format_string
end

early-header-c
  code
#   include "jitterlisp.h"
  end
end

initialization-c
  code
    printf ("Hello from the Jittery per-run initialization...\n");
    //jitter_log_instruction (BEFORE, 0, NULL/*& jitter_state_runtime*/, jitter_state_runtime, & original_state->vmprefix_state_backing);
    //printf ("Done with the Jittery per-run initialization\n");
printf ("TOP: %p\n", (void*)JITTERLISPVM_TOP_MAINSTACK());
printf ("UT:  %p\n", (void*)JITTERLISPVM_UNDER_TOP_MAINSTACK());
    printf ("...Now running the code.\n");
  end
end

finalization-c
  code
    printf ("Goodbye from the Jittery run\n");
  end
end

early-c
  code
#   include <stdio.h>
  end
end
late-c
  code
// FIXME: this obviously breaks optimization, and is only for debugging.

//#define the_jitter_state_runtime_pointer (& jitter_state_runtime)
//#define the_jitter_state_runtime_pointer (jitter_state_runtime)
#define the_jitter_state_runtime_pointer NULL

#define the_jitter_state_runtime_type typeof (the_jitter_state_runtime_pointer)
//#define the_jitter_state_runtime_type struct jitterlispvm_state_runtime

#define state_runtime_selector .

__attribute__ ((unused))
void
debug_pointer (jitter_int index, const void *pointer)
{
  return;
  printf ("[DEBUG: %lli %p]\n", (long long) index, pointer);
  fflush (stdout);
}

// FIXME: move this functionality into Jitter.
__attribute__ ((unused))
static void
jitter_log_instruction (int order,
                        jitter_int specialized_opcode,
                        //const struct jitterlispvm_state_runtime *rp,
                        const struct jitterlispvm_state_runtime r,
                        const struct jitterlispvm_state_backing *b
                        )
{
  static int counter = 0;
  char *order_string;
  switch (order)
    {
    case BEFORE: order_string = "Before"; break;
    case BEGINNING: order_string = "At the beginning of"; break;
    case END_OF: order_string = "At the end of"; break;
    case AFTER:  order_string = "After"; break;
    default:
      jitter_fatal ("unknown order %i", (int) order);
    }
  //const struct jitterlispvm_state_runtime r = *rp;
  printf ("%i.  %s specialized instruction %s\n",
          counter ++,
          order_string,
          jitterlispvm_specialized_instruction_names [specialized_opcode]);

  const struct jitter_stack_backing *mainstack_backing
    = & b->jitter_stack_mainstack_backing;
  const jitterlisp_object *mainstack_memory
    = (const jitterlisp_object *) mainstack_backing->memory;
  jitterlisp_object mainstack_top
    = r.jitter_tos_optimized_stack_mainstack_top;
  const jitterlisp_object *mainstack_undertop_p
    = r.jitter_tos_optimized_stack_mainstack_under_top_p;

  const struct jitter_stack_backing *returnstack_backing
    = & b->jitter_stack_returnstack_backing;
  const jitterlisp_object *returnstack_memory
    = (const jitterlisp_object *) returnstack_backing->memory;
  const jitterlisp_object *returnstack_top_p
    = r.jitter_non_tos_optimized_stack_returnstack_top_p;

  const jitterlisp_object *p;

  printf ("  Main stack (height %li + 1):\n", (long int) (mainstack_undertop_p - mainstack_memory) + 1);
  printf ("    %18s: %p\n", "Top", (void*) mainstack_top);
  for (p = mainstack_undertop_p; p >= mainstack_memory; p --)
    printf ("    %18p: %p\n", p, (void*) *p);

  printf ("  Return stack (height %li):\n", (long int) (returnstack_top_p - returnstack_memory) + 1);
  for (p = returnstack_top_p; p >= returnstack_memory; p --)
    printf ("    %18p: %p\n", p, (void*) *p);
  printf ("%%r0: %p\n", (void*) r.jitter_fast_register_r_0);
  printf ("%%r1: %p\n", (void*) r.jitter_fast_register_r_1);

  printf ("\n");
  fflush (stdout);
}

__attribute__ ((unused))
static void
dump_stacks (int where, the_jitter_state_runtime_type state_runtime)
{
return;
/*
  printf ("In ");
  switch (where)
    {
    case 0:
      printf ("prolog");
      break;
    case 1:
      printf ("return before popping");
      break;
    case 2:
      printf ("return after popping");
      break;
    case 3:
      printf ("call before making place");
      break;
    case 4:
      printf ("call after making place");
      break;
    default:
      printf ("unknown");
    }
  printf (":\n");
  jitter_uint mainstack_top
    = JITTER_STACK_TOS_TOP(jitterlisp_object,
                           state_runtime state_runtime_selector,
                           mainstack);
  jitter_uint mainstack_undertop
    = JITTER_STACK_TOS_UNDER_TOP(jitterlisp_object,
                                 state_runtime state_runtime_selector,
                                 mainstack);
  jitter_uint returnstack_top
    = JITTER_STACK_NTOS_TOP(jitterlisp_object,
                            state_runtime state_runtime_selector,
                            returnstack);
  jitter_uint returnstack_undertop
    = JITTER_STACK_NTOS_UNDER_TOP(jitterlisp_object,
                                  state_runtime state_runtime_selector,
                                  returnstack);
  printf ("* Main:     %p %p\n",
           (void*) mainstack_undertop, (void*) mainstack_top);
  printf ("  Return:   %p %p\n",
          (void*) returnstack_undertop, (void*) returnstack_top);

  printf ("\n");
  */
}

/* Open an argument-type-checking sequence, for the given number of arguments
   to be read from the main stack.  This is a helper macro for
   JITTERLISPVM_CHECK_TYPES_* . */
#define JITTERLISPVM_BEGIN_CHECK_TYPES_(_jitterlisp_vm_in_arity)  \
  JITTER_BEGIN_                                                   \
    int _jitterlispvm_arg_no = (_jitterlisp_vm_in_arity);         \
    int _jitterlispvm_arg_index __attribute__ ((unused)) = 0;     \
    int _jitterlispvm_arg_depth __attribute__ ((unused)) \
      = _jitterlispvm_arg_no - 1;

/* Check the next argument in the sequence, failing if its type doesn't match
   the given uppercase suffix.  Do nothing if compiling an unsafe JitterLisp. */
#ifdef JITTERLISP_UNSAFE
# define JITTERLISPVM_CHECK_NEXT_TYPE_(_jitterlisp_uppercase_type,    \
                                       _jitterlisp_error_fast_label)  \
    { /* Do nothing. */ }
#else
# define JITTERLISPVM_CHECK_NEXT_TYPE_(_jitterlisp_uppercase_type,     \
                                       _jitterlisp_error_fast_label)   \
    {                                                                  \
      bool _jitterlisp_is_valid __attribute__ ((unused))               \
        = (JITTER_CONCATENATE_TWO(JITTERLISP_IS_,                      \
                                  _jitterlisp_uppercase_type)(         \
              (JITTER_AT_DEPTH_MAINSTACK(_jitterlispvm_arg_depth))));  \
      /* FIXME: None of the following four ways of jumping is really   \
         satisfactory.  They are all slow or bloated in different      \
         ways, and which one is the least bad depends on the           \
         architecture. */                                              \
      /* JITTER_BRANCH_FAST_IF_ZERO(_jitterlisp_is_valid,              \
                                    _jitterlisp_error_fast_label); */  \
      if (! __builtin_expect (_jitterlisp_is_valid, true))             \
        JITTER_BRANCH_FAST(_jitterlisp_error_fast_label);              \
      /* if (! __builtin_expect (_jitterlisp_is_valid, true))          \
        jitterlisp_fail_from_vm (); */                                 \
      /* if (! __builtin_expect (_jitterlisp_is_valid, true))          \
         JITTERLISPVM_ERROR_INVALID_PRIMITIVE_ARGUMENT_TYPE_; */       \
      _jitterlispvm_arg_depth --;                                      \
      _jitterlispvm_arg_index ++;                                      \
    }
#endif // #ifdef JITTERLISP_UNSAFE

/* Close an argument-type-checking sequence.  This is a helper macro for
   JITTERLISPVM_CHECK_TYPES_* . */
#define JITTERLISPVM_END_CHECK_TYPES_  \
  JITTER_END_

/* For in-arity N, check that the topmost N arguments have the given N types
   expressed as uppercase suffixes, respectively.  This functionality is
   provided for a few common values of N . */
#define JITTERLISPVM_CHECK_TYPES_1(_jitterlisp_uppercase_type_0,  \
                                   _jitterlisp_error_fast_label)  \
  JITTERLISPVM_BEGIN_CHECK_TYPES_(1)                              \
    JITTERLISPVM_CHECK_NEXT_TYPE_(_jitterlisp_uppercase_type_0,   \
                                  _jitterlisp_error_fast_label);  \
  JITTERLISPVM_END_CHECK_TYPES_
#define JITTERLISPVM_CHECK_TYPES_2(_jitterlisp_uppercase_type_0,  \
                                   _jitterlisp_uppercase_type_1,  \
                                   _jitterlisp_error_fast_label)  \
  JITTERLISPVM_BEGIN_CHECK_TYPES_(2)                              \
    JITTERLISPVM_CHECK_NEXT_TYPE_(_jitterlisp_uppercase_type_0,   \
                                  _jitterlisp_error_fast_label);  \
    JITTERLISPVM_CHECK_NEXT_TYPE_(_jitterlisp_uppercase_type_1,   \
                                  _jitterlisp_error_fast_label);  \
  JITTERLISPVM_END_CHECK_TYPES_
#define JITTERLISPVM_CHECK_TYPES_3(_jitterlisp_uppercase_type_0,  \
                                   _jitterlisp_uppercase_type_1,  \
                                   _jitterlisp_uppercase_type_2,  \
                                   _jitterlisp_error_fast_label)  \
  JITTERLISPVM_BEGIN_CHECK_TYPES_(3)                              \
    JITTERLISPVM_CHECK_NEXT_TYPE_(_jitterlisp_uppercase_type_0,   \
                                  _jitterlisp_error_fast_label);  \
    JITTERLISPVM_CHECK_NEXT_TYPE_(_jitterlisp_uppercase_type_1,   \
                                  _jitterlisp_error_fast_label);  \
    JITTERLISPVM_CHECK_NEXT_TYPE_(_jitterlisp_uppercase_type_2,   \
                                  _jitterlisp_error_fast_label);  \
  JITTERLISPVM_END_CHECK_TYPES_
#define JITTERLISPVM_CHECK_TYPES_4(_jitterlisp_uppercase_type_0,  \
                                   _jitterlisp_uppercase_type_1,  \
                                   _jitterlisp_uppercase_type_2,  \
                                   _jitterlisp_uppercase_type_3,  \
                                   _jitterlisp_error_fast_label)  \
  JITTERLISPVM_BEGIN_CHECK_TYPES_(4)                              \
    JITTERLISPVM_CHECK_NEXT_TYPE_(_jitterlisp_uppercase_type_0,   \
                                  _jitterlisp_error_fast_label);  \
    JITTERLISPVM_CHECK_NEXT_TYPE_(_jitterlisp_uppercase_type_1,   \
                                  _jitterlisp_error_fast_label);  \
    JITTERLISPVM_CHECK_NEXT_TYPE_(_jitterlisp_uppercase_type_2,   \
                                  _jitterlisp_error_fast_label);  \
    JITTERLISPVM_CHECK_NEXT_TYPE_(_jitterlisp_uppercase_type_3,   \
                                  _jitterlisp_error_fast_label);  \
  JITTERLISPVM_END_CHECK_TYPES_

#if 0
# define JITTERLISPVM_ERROR_INVALID_PRIMITIVE_ARGUMENT_TYPE_          \
    jitterlispvm_error_invalid_primitive_argument_type_unfriendly ()
#else
# define JITTERLISPVM_ERROR_INVALID_PRIMITIVE_ARGUMENT_TYPE_     \
    jitterlispvm_error_invalid_primitive_argument_type_friendly  \
       (JITTER_SPECIALIZED_INSTRUCTION_OPCODE,                   \
        _jitterlispvm_arg_index,                                 \
        JITTER_AT_DEPTH_MAINSTACK(_jitterlispvm_arg_depth))
#endif


// Unfortunately the attribute is invisible across the wrapper.
// This is convenient for debugging, but I don't want to use it in production:
// passing parameters at every call makes the code much bigger, even if the
// call is not executed.
__attribute__ ((noreturn, unused))
static void
jitterlispvm_error_invalid_primitive_argument_type_friendly
   (int sins_opcode,
    int arg_index,
    jitterlisp_object o)
{
  /* Print information about the argument and its hex representation:
     don't dare yet to print it as a Lisp object, as the printer might
     crash if there is a bug and the object is invalid. */
  printf ("%s: About the %i-th (0-based) primitive argument %p\n",
          jitterlispvm_specialized_instruction_names [sins_opcode],
          arg_index, (void *) o);

  /* This shouldn't be needed on GNU, but flush stdout so that we can be
     sure that the previous line is visible before we crash. */
  fflush (stdout);

  /* Okay, now we can print in in Lisp. */
  printf ("  (in Lisp ");
  jitterlisp_print_to_stream (stdout, o);
  printf ("):\n");

  jitterlisp_error_cloned ("invalid primitive argument type");
}

__attribute__ ((noreturn, unused))
static void
jitterlispvm_error_invalid_primitive_argument_type_unfriendly (void)
{
  jitterlisp_error_cloned ("invalid primitive argument type");
}

static void
jitterlisp_fail_from_vm (void)
{
  jitterlisp_error_cloned ("unspecified error raised by VM code");
}

/* This is convenient for testing.  FIXME: remove. */
__attribute__ ((unused))
static void
log_ (long n)
{
  printf ("Log: %li\n", n);
}

    static const char *stack_printf_format_string __attribute__ ((unused))
      = "%" JITTER_PRIi "\n";
  end
end




## Custom literal argument printer.
#################################################################

printer-c
  code
/* Print a Lisp object in Lisp notation.  This is convenient to read VM
   programs in textual form. */
static void
print_object (FILE *out, jitter_uint u)
{
  jitterlisp_print_to_stream (out, u);
}
  end
end




## Debugging code for instructions.
#################################################################

early-c
  code
#define BEFORE    1
#define BEGINNING 2
#define AFTER     3
#define END_OF    4
  end
end

late-c
#initialization-c
  code
    //static
jitter_uint last_specialized_opcode __attribute__ ((unused))
  = -1;
  end
end

instruction-beginning-c
  code
  /*
    if (JITTER_SPECIALIZED_INSTRUCTION_OPCODE
        != jitterlispvm_specialized_instruction_opcode_debug
        )
      {
        last_specialized_opcode = JITTER_SPECIALIZED_INSTRUCTION_OPCODE;
        jitter_log_instruction (BEGINNING,
                                last_specialized_opcode,
                                ((const struct jitterlispvm_state_runtime)
                                 jitter_state_runtime),
                                ((const struct jitterlispvm_state_backing *)
                                 & original_state->vmprefix_state_backing));
        asm volatile ("nop");
        asm volatile ("nop");
      }
  */
//putchar ('[');
  end
end

instruction-end-c
  code
  //    putchar (']');
  /*
    asm volatile ("nop");
    asm volatile ("nop");
    jitter_log_instruction (END_OF,
                            last_specialized_opcode,
                            ((const struct jitterlispvm_state_runtime)
                             jitter_state_runtime),
                            ((const struct jitterlispvm_state_backing *)
                             & original_state->vmprefix_state_backing));
  */
  end
end

instruction debug ()
  # non-relocatable
  cold
  code
    jitter_int opcode;
opcode = last_specialized_opcode;
//    opcode = 0;
    // putchar ('*'); putchar ('\n');
    jitter_log_instruction (AFTER,
                            opcode,
                            ((const struct jitterlispvm_state_runtime)
                             jitter_state_runtime),
                            ((const struct jitterlispvm_state_backing *)
                             & original_state->vmprefix_state_backing));

/*
*/
  //(void)previous_specialized_opcode;
  /*
  static int i = 0;
  printf ("%i. After specialized instruction %s\n", i ++,
          jitterlispvm_specialized_instruction_names [previous_specialized_opcode]);
  struct jitterlispvm_state_backing * const b
    = & original_state->vmprefix_state_backing;

  const struct jitter_stack_backing *mainstack_backing
    = & b->jitter_stack_mainstack_backing;
  const jitterlisp_object *mainstack_memory
    = (const jitterlisp_object *) mainstack_backing->memory;
  jitterlisp_object mainstack_top
    = jitter_state_runtime.jitter_tos_optimized_stack_mainstack_top;
  const jitterlisp_object *mainstack_undertop_p
    = jitter_state_runtime.jitter_tos_optimized_stack_mainstack_under_top_p;

  const struct jitter_stack_backing *returnstack_backing
    = & b->jitter_stack_returnstack_backing;
  const jitterlisp_object *returnstack_memory
    = (const jitterlisp_object *) returnstack_backing->memory;
  const jitterlisp_object *returnstack_top_p
    = jitter_state_runtime.jitter_non_tos_optimized_stack_returnstack_top_p;

  const jitterlisp_object *p;

  printf ("  Main stack (height %li + 1):\n", (long int) (mainstack_undertop_p - mainstack_memory) + 1);
  printf ("    %18s: %p\n", "Top", (void*) mainstack_top);
  for (p = mainstack_undertop_p; p >= mainstack_memory; p --)
    printf ("    %18p: %p\n", p, (void*) *p);

  printf ("  Return stack (height %li):\n", (long int) (returnstack_top_p - returnstack_memory) + 1);
  for (p = returnstack_top_p; p >= returnstack_memory; p --)
    printf ("    %18p: %p\n", p, (void*) *p);

  printf ("\n");
  fflush (stdout);
*/
  end
end




## Instructions.
#################################################################

instruction nop ()
  code
  end
end

instruction dup ()
  code
    JITTER_DUP_MAINSTACK();
  end
end

instruction drop ()
  code
    JITTER_DROP_MAINSTACK();
  end
end

instruction nip ()
  code
    JITTER_NIP_MAINSTACK();
  end
end

# FIXME: is this ever needed?
instruction push-unspecified ()
  code
    JITTER_PUSH_UNSPECIFIED_MAINSTACK();
  end
end

instruction push-register (?R)
  code
    jitterlisp_object k = JITTER_ARG0;
    JITTER_PUSH_MAINSTACK(k);
  end
end

instruction push-literal (?n print_object)
  code
    jitterlisp_object k = JITTER_ARGN0;
    JITTER_PUSH_MAINSTACK(k);
  end
end

instruction push-global (?n print_object)
  code
    jitterlisp_object tagged_symbol = JITTER_ARGN0;
    struct jitterlisp_symbol *symbol = JITTERLISP_SYMBOL_DECODE(tagged_symbol);
    JITTER_PUSH_MAINSTACK(symbol->global_value);
  end
end

# FIXME: use these, in rewrites.
instruction push-nil ()
  code
    JITTER_PUSH_MAINSTACK(JITTERLISP_EMPTY_LIST);
  end
end
instruction push-zero ()
  code
    JITTER_PUSH_MAINSTACK(JITTERLISP_FIXNUM_ENCODE(0));
  end
end
instruction push-one ()
  code
    JITTER_PUSH_MAINSTACK(JITTERLISP_FIXNUM_ENCODE(1));
  end
end
instruction push-false ()
  code
    JITTER_PUSH_MAINSTACK(JITTERLISP_FALSE);
  end
end
instruction push-nothing ()
  code
    JITTER_PUSH_MAINSTACK(JITTERLISP_NOTHING);
  end
end

instruction pop-to-register (!R)
  code
    jitterlisp_object top = JITTER_TOP_MAINSTACK();
    JITTER_DROP_MAINSTACK();
    JITTER_ARG0 = top;
  end
end

instruction pop-to-global (?n print_object)
  code
    jitterlisp_object tagged_symbol = JITTER_ARGN0;
    struct jitterlisp_symbol *symbol = JITTERLISP_SYMBOL_DECODE(tagged_symbol);
    symbol->global_value = JITTER_TOP_MAINSTACK();
    JITTER_DROP_MAINSTACK();
  end
end

instruction copy-to-register (!R)
  code
    JITTER_ARG0 = JITTER_TOP_MAINSTACK();
  end
end

instruction copy-from-register (?R)
  code
    JITTER_TOP_MAINSTACK() = JITTER_ARG0;
  end
end

instruction copy-from-literal (?n print_object)
  code
    JITTER_TOP_MAINSTACK() = JITTER_ARGN0;
  end
end

instruction literal-to-register (?n print_object, !R)
  code
    JITTER_ARG1 = JITTER_ARGN0;
  end
end

instruction register-to-register (?R, !R)
  code
    JITTER_ARG1 = JITTER_ARG0;
  end
end

# Do a check on the top element, fast-branching to the given error-handling
# routine in case of mismatch, and do nothing otherwise.
# This does *not* pop an operand from the stack.
instruction check-closure (?f)
  code
    jitterlisp_object top = JITTER_TOP_MAINSTACK();
    if (! JITTERLISP_IS_CLOSURE(top))
      JITTER_BRANCH_FAST(JITTER_ARGF0);
  end
end

instruction branch (?f)
  code
    JITTER_BRANCH_FAST(JITTER_ARGF0);
  end
end

instruction branch-if-false (?f)
  code
    jitterlisp_object top = JITTER_TOP_MAINSTACK();
    JITTER_DROP_MAINSTACK();
/*
asm volatile (""//"add $0, %[old_top], %[new_top]"
     : [old_top] "+X" (top)
       , [new_top] "+X" (JITTER_TOP_MAINSTACK())
     );
*/
/*
// Not only this generates terrible code: it also makes the TOS update
// e nd up after the branch.
asm volatile (""
     : [top] "+X" (top)
     : [state] "X" (jitter_state_runtime)
     );
*/
/*
// Equally useless.
asm volatile ("" : : : "memory");
*/
//asm volatile ("" : "+X" (top) : : "memory");
asm goto ("" : : "X"(top): : after);
    JITTER_BRANCH_FAST_IF_EQUAL(top, JITTERLISP_FALSE, JITTER_ARGF0);
//__builtin_unreachable ();
after:;
/*asm volatile ("addi $0, $0, 20"
     : "+X" (JITTER_TOP_MAINSTACK())
     );*/
//a_label: ;
  end
end

# Just an instruction using the top, even in an incorrect way.  Testing
# branch-if-false compilation.
instruction dummy ()
  code
    printf ("%li\n", (long)JITTER_TOP_MAINSTACK());
  end
end

instruction branch-if-true (?f)
  code
    jitterlisp_object top = JITTER_TOP_MAINSTACK();
    JITTER_DROP_MAINSTACK();
    JITTER_BRANCH_FAST_IF_NOTEQUAL(top, JITTERLISP_FALSE, JITTER_ARGF0);
  end
end

instruction branch-if-null (?f)
  code
    jitterlisp_object top = JITTER_TOP_MAINSTACK();
    JITTER_DROP_MAINSTACK();
    JITTER_BRANCH_FAST_IF_EQUAL(top, JITTERLISP_EMPTY_LIST, JITTER_ARGF0);
  end
end

instruction canonicalize-boolean ()
  code
    JITTERLISP_BOOLEAN_CANONICALIZE_(JITTER_TOP_MAINSTACK(),
                                     JITTER_TOP_MAINSTACK());
  end
end

# The first argument is a primitive function pointer.
# The second is its in-arity.
instruction primitive (?n, ?n 0 1 2 3 4, ?f)
  # non-relocatable
  code
    /* The error-handling label is not actually used in this case: the
       primitive function, written in C, has its own handling.  It's
       harmless to have it anyway, as it makes the C code generator
       more uniform. */
    jitterlisp_primitive_function p
      = (jitterlisp_primitive_function) JITTER_ARGP0;
    const jitter_uint in_arity = JITTER_ARGN1;
    JITTER_PUSH_UNSPECIFIED_MAINSTACK();
    //asm volatile ("nop");
    jitterlisp_object *first_arg
      // FIXME: add a stack operator to compute this address.
      = (& JITTER_UNDER_TOP_MAINSTACK()) - in_arity + 1;
    //asm volatile ("nop" : : "X" (first_arg));
    jitterlisp_object res = p (first_arg);
    jitter_uint i;
    // Remove as many elements as the primitive in-arity, but not more:
    // the top unspecified value we pushed will be replaced with the result.
    for (i = 0; i < in_arity; i ++)
      JITTER_NIP_MAINSTACK();
    JITTER_TOP_MAINSTACK() = res;
  end
end

instruction primitive-car (?f)
  code
    JITTERLISPVM_CHECK_TYPES_1(CONS, JITTER_ARGF0);
    JITTERLISP_CAR_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-cdr (?f)
  code
    JITTERLISPVM_CHECK_TYPES_1(CONS, JITTER_ARGF0);
    JITTERLISP_CDR_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-cons (?f)
  code
    /* When this compiles to a total of five or six instructions in the
       fast path I'll be a happy man. */
    JITTERLISP_CONS_(JITTER_TOP_MAINSTACK(),
                     JITTER_UNDER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-eqp (?f)
  code
    JITTERLISPVM_CHECK_TYPES_2(ANYTHING, ANYTHING, JITTER_ARGF0);
    JITTERLISP_EQP_(JITTER_TOP_MAINSTACK(),
                    JITTER_UNDER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-not-eqp (?f)
  code
    JITTERLISPVM_CHECK_TYPES_2(ANYTHING, ANYTHING, JITTER_ARGF0);
    JITTERLISP_NOT_EQP_(JITTER_TOP_MAINSTACK(),
                        JITTER_UNDER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-fixnum-eqp (?f)
  code
    JITTERLISPVM_CHECK_TYPES_2(FIXNUM, FIXNUM, JITTER_ARGF0);
    JITTERLISP_EQP_(JITTER_TOP_MAINSTACK(),
                    JITTER_UNDER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-fixnum-not-eqp (?f)
  code
    JITTERLISPVM_CHECK_TYPES_2(FIXNUM, FIXNUM, JITTER_ARGF0);
    JITTERLISP_NOT_EQP_(JITTER_TOP_MAINSTACK(),
                        JITTER_UNDER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-zerop (?f)
  code
    JITTERLISPVM_CHECK_TYPES_1(FIXNUM, JITTER_ARGF0);
    JITTERLISP_ZEROP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-non-zerop (?f)
  code
    JITTERLISPVM_CHECK_TYPES_1(FIXNUM, JITTER_ARGF0);
    JITTERLISP_NON_ZEROP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-positivep (?f)
  code
    JITTERLISPVM_CHECK_TYPES_1(FIXNUM, JITTER_ARGF0);
    JITTERLISP_POSITIVEP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-non-positivep (?f)
  code
    JITTERLISPVM_CHECK_TYPES_1(FIXNUM, JITTER_ARGF0);
    JITTERLISP_NON_POSITIVEP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-negativep (?f)
  code
    JITTERLISPVM_CHECK_TYPES_1(FIXNUM, JITTER_ARGF0);
    JITTERLISP_NEGATIVEP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-non-negativep (?f)
  code
    JITTERLISPVM_CHECK_TYPES_1(FIXNUM, JITTER_ARGF0);
    JITTERLISP_NON_NEGATIVEP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-lessp (?f)
  code
    JITTERLISPVM_CHECK_TYPES_2(FIXNUM, FIXNUM, JITTER_ARGF0);
    JITTERLISP_LESSP_(JITTER_TOP_MAINSTACK(),
                      JITTER_UNDER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-greaterp (?f)
  code
    JITTERLISPVM_CHECK_TYPES_2(FIXNUM, FIXNUM, JITTER_ARGF0);
    JITTERLISP_GREATERP_(JITTER_TOP_MAINSTACK(),
                         JITTER_UNDER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-not-lessp (?f)
  code
    JITTERLISPVM_CHECK_TYPES_2(FIXNUM, FIXNUM, JITTER_ARGF0);
    JITTERLISP_NOTLESSP_(JITTER_TOP_MAINSTACK(),
                         JITTER_UNDER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-not-greaterp (?f)
  code
    JITTERLISPVM_CHECK_TYPES_2(FIXNUM, FIXNUM, JITTER_ARGF0);
    JITTERLISP_NOTGREATERP_(JITTER_TOP_MAINSTACK(),
                            JITTER_UNDER_TOP_MAINSTACK(),
                            JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-one-plus (?f)
  code
    JITTERLISPVM_CHECK_TYPES_1(FIXNUM, JITTER_ARGF0);
    JITTERLISP_1PLUS_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-one-minus (?f)
  code
    JITTERLISPVM_CHECK_TYPES_1(FIXNUM, JITTER_ARGF0);
    JITTERLISP_1MINUS_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-two-times (?f)
  code
    JITTERLISPVM_CHECK_TYPES_1(FIXNUM, JITTER_ARGF0);
    JITTERLISP_2TIMES_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-two-divided (?f)
  code
    JITTERLISPVM_CHECK_TYPES_1(FIXNUM, JITTER_ARGF0);
    JITTERLISP_2DIVIDED_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-two-remainder (?f)
  code
    JITTERLISPVM_CHECK_TYPES_1(FIXNUM, JITTER_ARGF0);
    JITTERLISP_2REMAINDER_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-negate (?f)
  code
    JITTERLISPVM_CHECK_TYPES_1(FIXNUM, JITTER_ARGF0);
    JITTERLISP_NEGATE_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-primordial-plus (?f)
  code
    JITTERLISPVM_CHECK_TYPES_2(FIXNUM, FIXNUM, JITTER_ARGF0);
    JITTERLISP_PLUS_(JITTER_TOP_MAINSTACK(),
                     JITTER_UNDER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-primordial-minus (?f)
  code
    JITTERLISPVM_CHECK_TYPES_2(FIXNUM, FIXNUM, JITTER_ARGF0);
    JITTERLISP_MINUS_(JITTER_TOP_MAINSTACK(),
                      JITTER_UNDER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-primordial-times (?f)
  code
    JITTERLISPVM_CHECK_TYPES_2(FIXNUM, FIXNUM, JITTER_ARGF0);
    JITTERLISP_TIMES_(JITTER_TOP_MAINSTACK(),
                      JITTER_UNDER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-primordial-divided-unsafe (?f)
  code
    /* The second argument has already been validated if we are using this. */
    JITTERLISPVM_CHECK_TYPES_2(FIXNUM, ANYTHING, JITTER_ARGF0);
    JITTERLISP_DIVIDED_UNSAFE_(JITTER_TOP_MAINSTACK(),
                               JITTER_UNDER_TOP_MAINSTACK(),
                               JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-quotient-unsafe (?f)
  code
    /* The second argument has already been validated if we are using this. */
    JITTERLISPVM_CHECK_TYPES_2(FIXNUM, ANYTHING, JITTER_ARGF0);
    JITTERLISP_QUOTIENT_UNSAFE_(JITTER_TOP_MAINSTACK(),
                               JITTER_UNDER_TOP_MAINSTACK(),
                               JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-remainder-unsafe (?f)
  code
    /* The second argument has already been validated if we are using this. */
    JITTERLISPVM_CHECK_TYPES_2(FIXNUM, ANYTHING, JITTER_ARGF0);
    JITTERLISP_REMAINDER_UNSAFE_(JITTER_TOP_MAINSTACK(),
                                 JITTER_UNDER_TOP_MAINSTACK(),
                                 JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-nullp (?f)
  code
    JITTERLISP_NULLP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-non-nullp (?f)
  code
    JITTERLISP_NON_NULLP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-nothingp (?f)
  code
    JITTERLISP_NOTHINGP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-fixnump (?f)
  code
    JITTERLISP_FIXNUMP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-characterp (?f)
  code
    JITTERLISP_CHARACTERP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-consp (?f)
  code
    JITTERLISP_CONSP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-non-consp (?f)
  code
    JITTERLISP_NON_CONSP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-symbolp (?f)
  code
    JITTERLISP_SYMBOLP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-non-symbolp (?f)
  code
    JITTERLISP_NON_SYMBOLP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-not (?f)
  code
    JITTERLISP_NOT_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-boolean-canonicalize (?f)
  code
    JITTERLISP_BOOLEAN_CANONICALIZE_(JITTER_TOP_MAINSTACK(),
                                     JITTER_TOP_MAINSTACK());
  end
end

# Take a compiled closure (no type checking), its arguments already evaluated,
# and the number of arguments (untagged) on the top of stack.  Replace all the
# stack operands with the call result.
# Rationale: this instruction has been designed to be the first and only
# instruction executed in the driver VM program, called from the AST interpreter
# in C.
# The same driver program can be generated once at initialization, and then
# reused to launch procedures as needed: this is why the instruction takes
# the closure in-arity from the stack instead of from an instruction argument.
instruction call-from-c ()
  caller
  code
  /*
    jitter_log_instruction (0,
                            //0,//JITTER_SPECIALIZED_INSTRUCTION_OPCODE,
                            ((const struct jitterlispvm_state_runtime)
                             jitter_state_runtime),
                            ((const struct jitterlispvm_state_backing *)
                             & original_state->vmprefix_state_backing));
  */
  /*
debug_pointer (-100, (const void*) JITTER_TOP_MAINSTACK());
debug_pointer (-101, (const void*) JITTER_UNDER_TOP_MAINSTACK());
debug_pointer (0, NULL);
debug_pointer (0, NULL);*/

    /* Pop a number (untagged) off the stack, so that I know at which
       depth to find the closure.  The arity check must have been
       performed already on the interpreter side. */
    const jitter_uint in_arity = JITTER_TOP_MAINSTACK();
    JITTER_DROP_MAINSTACK();

/*
debug_pointer (-200, (const void*) JITTER_TOP_MAINSTACK());
debug_pointer (-201, (const void*) JITTER_UNDER_TOP_MAINSTACK());
debug_pointer (0, NULL);
debug_pointer (0, NULL);*/
    /* What follows is similar to the call instruction in the case of a compiled
       callee.  Shall I factor the common code with a macro? */

    /* Decode the closure. */
/*
debug_pointer (in_arity, NULL);
debug_pointer (-2, & JITTER_UNDER_TOP_MAINSTACK());
    jitterlisp_object * callee_p
      = (& JITTER_UNDER_TOP_MAINSTACK()) - (in_arity - 1);
      debug_pointer (-1, callee_p); */
    jitterlisp_object callee = JITTER_AT_DEPTH_MAINSTACK(in_arity);
/*asm ("# %[q]" : [q] "+rm" (callee));
  debug_pointer (0, (const void*)callee);*/
    struct jitterlisp_closure *c = JITTERLISP_CLOSURE_DECODE(callee);
/*asm ("# %[q]" : [q]"+rm" (c));
  debug_pointer (1, (const void*)c);*/
    struct jitterlisp_compiled_closure *cc = & c->compiled;
/*asm ("# %[q]" : [q]"+rm" (cc));
debug_pointer (2, (const void*)cc);
asm ("# %[q]" : [q]"+rm" (cc));
debug_pointer (4, cc->first_program_point);*/

    /* Make place for the return address in the return stack.  The
       actual value will be written by the callee. */
    JITTER_PUSH_UNSPECIFIED_RETURNSTACK();
    JITTER_TOP_RETURNSTACK() = 0x4242aaaa; // FIXME: just a test.  Remove.

    /* Branch-and-link.  This follows the ordinary calling convention,
       with the main stack containing the closure and its actuals, known
       to be in the correct number.  The next VM instruction will be a
       prolog saving the link; then execution will fall thru into the
       compiled closure body. */
    JITTER_BRANCH_AND_LINK(cc->first_program_point);
  end
end

# This is the generic code working for both compiled and interpreted closures.
# FIXME: add a call-compiled instruction, to be generated when the callee is
# known at compile time to be compiled.
instruction call (?n 0 1 2 3 4 5 6 7 8 9 10)
  caller
  code
    const jitter_uint in_arity = JITTER_ARGN0;
    jitterlisp_object callee = JITTER_AT_DEPTH_MAINSTACK(in_arity);
    struct jitterlisp_closure *c = JITTERLISP_CLOSURE_DECODE(callee);

    if (c->kind == jitterlisp_closure_type_compiled)
      {
        /* Make place for the return address in the return stack.  The
           actual value will be written by the callee. */
        JITTER_PUSH_UNSPECIFIED_RETURNSTACK();
        JITTER_TOP_RETURNSTACK() = 0x4242aaaa; // FIXME: just a test.  Remove.

        /* Branch-and-link to the native code, whose first instruction
           will be a prolog. */
        struct jitterlisp_compiled_closure *cc = & c->compiled;
        // FIXME: store the code beginnig as a closure field, to avoid
        // indirections here.
        JITTER_BRANCH_AND_LINK(cc->first_program_point);
      }
    else
      {
        const struct jitterlisp_interpreted_closure *ic = & c->interpreted;

        /* Push an element on the main stack.  This way we can ensure that
           every actual is accessible thru memory in a contiguous array,
           even if the main stack is TOS-optimized.  Compute the address
           (on the main stack backing) where the actuals begin.

           Notice that the interpreted function we are calling is allowed
           to call into compiled code in its turn.  This is not a problem,
           as we are not moving stack pointers down until the call ends:
           the unused part of the main and return stacks is available to
           the callee. */
        JITTER_PUSH_UNSPECIFIED_MAINSTACK();
        jitterlisp_object *actuals
          // FIXME: add a stack operator to compute this address.
          = (& JITTER_UNDER_TOP_MAINSTACK()) - in_arity + 1;

        /* Call the interpreter. */
putchar ('['); putchar ('i');
        jitterlisp_object interpretation_result
          = jitterlisp_call_interpreted (ic, actuals, in_arity);
putchar (']');

        /* Remove as many elements as the in-arity plus one (the callee) from
           the stack, without affecting the top.  Unless JITTER_ARGN0 is
           residual this whole loops compiles to one instruction when the main
           stack is TOS-optimized, and doesn't touch memory. */
        int i;
        for (i = 0; i < in_arity + 1; i ++)
          JITTER_NIP_MAINSTACK();

        /* Now the stack is one element higher than it was before the call,
           containing the unspecified element at the top.  Replace it with
           the result.  Again this doesn't touch memory. */
        JITTER_TOP_MAINSTACK() = interpretation_result;
      }
  end
end

instruction tail-call (?n)
#  caller  # Commented out to make the instruction rewritable.
  code
    /* FIXME: this is currently a dummy instruction, always rewritten away. */
    // FIXME: can I make compiled->interpreted calls tail?
  end
end

instruction procedure-prolog ()
  callee
  code
    /* Fill the return stack slot with the return address.  The return
       stack has already been pushed (with an unspecified value on the
       top) by the caller. */
    JITTER_TOP_RETURNSTACK() = (jitterlisp_object) JITTER_LINK;
    //dump_stacks (0, the_jitter_state_runtime_pointer);
  end
end

instruction return ()
  code
    //dump_stacks (1, the_jitter_state_runtime_pointer);
    jitter_uint return_address = JITTER_TOP_RETURNSTACK();
    JITTER_DROP_RETURNSTACK();
    //dump_stacks (2, the_jitter_state_runtime_pointer);
    JITTER_RETURN(return_address);
  end
end

instruction save-register (?R)
  code
    JITTER_PUSH_RETURNSTACK(JITTER_ARG0);
  end
end

instruction restore-register (!R)
  code
    JITTER_ARG0 = JITTER_TOP_RETURNSTACK();
    JITTER_DROP_RETURNSTACK();
  end
end

instruction fail ()
  non-relocatable
  cold
  code
    jitterlisp_fail_from_vm ();
  end
end




## Optimization rewrites.
#################################################################

rule rewrite
  pop-to-register $a; push-register $b
into
  copy-to-register $a; copy-from-register $b
end

rule rewrite
  pop-to-register $a; push-literal $b
into
  copy-to-register $a; copy-from-literal $b
end

rule rewrite
  push-literal $a; pop-to-register $b
into
  literal-to-register $a, $b
end

rule rewrite
  drop; push-register $a
into
  copy-from-register $a
end

rule rewrite
  drop; push-literal $a
into
  copy-from-literal $a
end

rule rewrite
  push-register $a; pop-to-register $b
into
  register-to-register $a, $b
end

rule rewrite
  copy-from-register $a; pop-to-register $b
into
  register-to-register $a, $b; drop
end

rule rewrite
  copy-from-literal $a; pop-to-register $b
into
  literal-to-register $a, $b; drop
end

rule rewrite
  push-register $a; push-register $a
into
  push-register $a; dup
end

rule rewrite
  copy-from-register $a; push-register $a
into
  copy-from-register $a; dup
end

rule rewrite
  copy-to-register $a; push-register $a
into
  copy-to-register $a; dup
end

rule rewrite
  copy-to-register $a; copy-from-register $a
into
  copy-to-register $a
end

rule rewrite
  push-literal $a; push-literal $a
into
  push-literal $a; dup
end

rule rewrite
  copy-from-literal $a; push-literal $a
into
  copy-from-literal $a; dup
end

rule rewrite
  push-register $a; drop
into
  # Nothing.
end

rule rewrite
  push-literal $a; drop
into
  # Nothing.
end

rule rewrite
  pop-to-register $a; copy-from-register $a
into
  copy-to-register $a; nip
end

rule rewrite
  pop-to-register $a; drop
into
  nip; pop-to-register $a
end

rule rewrite
  drop; drop
into
  nip; drop
end

# Having copy-to-register at the end might make it possible to combine
# with some other instruction; nip is not easy to combine, and in fact
# I currently have no other rule with nip on the left.
rule rewrite
  copy-to-register $a; nip
into
  nip; copy-to-register $a
end

rule rewrite
  pop-to-register $a; return
into
  drop; return
end

rule rewrite
  copy-to-register $a; return
into
  return
end

# The AST rewriter takes care of removing most "not; branch-if-*" sequences,
# including every use of "not" as a condition and every use of
# "boolean-canonicalize" as a guard or condition; however
# "not; branch-if-true" sequnces remain as while guards, where the branch is
# always on a true condiion (I compile while loops as do..while, with the
# conditional branch at the end).  It's easier to optimize this pattern here
# than to add a special case to the compiler.
rule rewrite
  primitive-not $a; branch-if-true $b
into
  branch-if-false $b
end

# # Some save/restore pairs are easy to eliminate.
# # FIXME: no, this never fires because of the implicit label after the call,
# # which makes the sequence non-rewritable.  Do I really want this behavior?
# # I suspect not.
# rule rewrite
#   save-register $a; call $b; restore-register $a; primitive-primordial-plus $c; return
# into
#   call $b; primitive-primordial-plus $c; return
# end



# FIXME: this is a temporary kludge, to be used before I actually implement
# tail calls.
rule remove-tail-calls rewrite
  tail-call $a
into
  call $a; return
end
