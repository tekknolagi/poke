## Jitter specification for the JitterLisp VM.

## Copyright (C) 2017, 2018 Luca Saiu
## Written by Luca Saiu

## This file is part of the Jittery Lisp language implementation, distributed as
## an example along with Jitter under the same license.

## Jitter is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.

## Jitter is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.

## You should have received a copy of the GNU General Public License
## along with Jitter.  If not, see <http://www.gnu.org/licenses/>.


## Global configuration.
#################################################################

vm
  set prefix "jitterlispvm"
  tos-stack "jitterlisp_object" "mainstack"

  # FIXME: the return stack might need a different type.  Or not.
  ntos-stack "jitterlisp_object" "returnstack"
end




## Register classes.
#################################################################

# We only need one register class.
register-class r 3
  code
    jitterlisp_object
  end
end




## Functions and globals to wrap.
#################################################################

# FIXME: these will need to grow.
wrapped-functions
  printf
  jitterlisp_print_to_stream
  jitterlispvm_error_invalid_primitive_argument_type
end

wrapped-globals
  stack_printf_format_string
  my_stdout_p
end

early-header-c
  code
#   include "jitterlisp.h"
  end
end

initialization-c
  code
    printf ("Hello from the Jittery VM initialization\n");
  end
end

finalization-c
  code
    printf ("Hello from the Jittery VM finalization\n");
  end
end

early-c
  code
#   include <stdio.h>
  end
end
late-c
  code
/* Open an argument-type-checking sequence, for the given number of arguments
   to be read from the main stack.  This is a helper macro for
   JITTERLISPVM_CHECK_TYPES_* . */
#define JITTERLISPVM_BEGIN_CHECK_TYPES_(_jitterlisp_vm_in_arity)  \
  JITTER_BEGIN_                                                   \
    int _jitterlispvm_arg_depth = (_jitterlisp_vm_in_arity) - 1;

/* Check the next argument in the sequence, failing if its type doesn't match
   the given uppercase suffix. */
#define JITTERLISPVM_CHECK_NEXT_TYPE_(_jitterlisp_uppercase_type)       \
  {                                                                     \
    if (! __builtin_expect(                                             \
             JITTER_CONCATENATE_TWO(JITTERLISP_IS_,                     \
                                    _jitterlisp_uppercase_type)(        \
                (JITTER_AT_DEPTH_MAINSTACK(_jitterlispvm_arg_depth))),  \
                           true))                                       \
      jitterlispvm_error_invalid_primitive_argument_type ();            \
    _jitterlispvm_arg_depth --;                                         \
  }

/* Close an argument-type-checking sequence.  This is a helper macro for
   JITTERLISPVM_CHECK_TYPES_* . */
#define JITTERLISPVM_END_CHECK_TYPES_  \
  JITTER_END_

/* For in-arity N, check that the topmost N arguments have the given N types
   expressed as uppercase suffixes, respectively.  This functionality is
   provided for a few common values of N . */
#define JITTERLISPVM_CHECK_TYPES_1(_jitterlisp_uppercase_type_0)  \
  JITTERLISPVM_BEGIN_CHECK_TYPES_(1)                              \
    JITTERLISPVM_CHECK_NEXT_TYPE_(_jitterlisp_uppercase_type_0);  \
  JITTERLISPVM_END_CHECK_TYPES_
#define JITTERLISPVM_CHECK_TYPES_2(_jitterlisp_uppercase_type_0,  \
                                   _jitterlisp_uppercase_type_1)  \
  JITTERLISPVM_BEGIN_CHECK_TYPES_(2)                              \
    JITTERLISPVM_CHECK_NEXT_TYPE_(_jitterlisp_uppercase_type_0);  \
    JITTERLISPVM_CHECK_NEXT_TYPE_(_jitterlisp_uppercase_type_1);  \
  JITTERLISPVM_END_CHECK_TYPES_
#define JITTERLISPVM_CHECK_TYPES_3(_jitterlisp_uppercase_type_0,  \
                                   _jitterlisp_uppercase_type_1,  \
                                   _jitterlisp_uppercase_type_2)  \
  JITTERLISPVM_BEGIN_CHECK_TYPES_(3)                              \
    JITTERLISPVM_CHECK_NEXT_TYPE_(_jitterlisp_uppercase_type_0);  \
    JITTERLISPVM_CHECK_NEXT_TYPE_(_jitterlisp_uppercase_type_1);  \
    JITTERLISPVM_CHECK_NEXT_TYPE_(_jitterlisp_uppercase_type_2);  \
  JITTERLISPVM_END_CHECK_TYPES_
#define JITTERLISPVM_CHECK_TYPES_4(_jitterlisp_uppercase_type_0,  \
                                   _jitterlisp_uppercase_type_1,  \
                                   _jitterlisp_uppercase_type_2,  \
                                   _jitterlisp_uppercase_type_3)  \
  JITTERLISPVM_BEGIN_CHECK_TYPES_(4)                              \
    JITTERLISPVM_CHECK_NEXT_TYPE_(_jitterlisp_uppercase_type_0);  \
    JITTERLISPVM_CHECK_NEXT_TYPE_(_jitterlisp_uppercase_type_1);  \
    JITTERLISPVM_CHECK_NEXT_TYPE_(_jitterlisp_uppercase_type_2);  \
    JITTERLISPVM_CHECK_NEXT_TYPE_(_jitterlisp_uppercase_type_3);  \
  JITTERLISPVM_END_CHECK_TYPES_

__attribute__ ((noreturn)) // Unfortunately this is invisible across the wrapper.
static void
jitterlispvm_error_invalid_primitive_argument_type (void)
{
  jitterlisp_error_cloned ("invalid primitive argument type");
}

    static const char *stack_printf_format_string = "%" JITTER_PRIi "\n";
    static FILE **my_stdout_p = & stdout;
  end
end




## Custom literal argument printer.
#################################################################

printer-c
  code
/* Print a Lisp object in Lisp notation.  This is convenient to read VM
   programs in textual form. */
static void
print_object (FILE *out, jitter_uint u)
{
  jitterlisp_print_to_stream (out, u);
}
  end
end




## Instructions.
#################################################################

instruction nop ()
  code
  end
end

instruction dup ()
  code
    JITTER_DUP_MAINSTACK();
  end
end

instruction drop ()
  code
    JITTER_DROP_MAINSTACK();
  end
end

instruction nip ()
  code
    JITTER_NIP_MAINSTACK();
  end
end

instruction push-unspecified ()
  code
    JITTER_PUSH_UNSPECIFIED_MAINSTACK();
  end
end

instruction push-register (?R)
  code
    jitterlisp_object k = JITTER_ARG0;
    JITTER_PUSH_MAINSTACK(k);
  end
end

instruction push-literal (?n print_object)
  code
    jitterlisp_object k = JITTER_ARGN0;
    JITTER_PUSH_MAINSTACK(k);
  end
end

instruction push-global (?n print_object)
  code
    jitterlisp_object tagged_symbol = JITTER_ARGN0;
    struct jitterlisp_symbol *symbol = JITTERLISP_SYMBOL_DECODE(tagged_symbol);
    JITTER_PUSH_MAINSTACK(symbol->global_value);
  end
end

instruction push-nil ()
  code
    JITTER_PUSH_MAINSTACK(JITTERLISP_EMPTY_LIST);
  end
end
instruction push-zero ()
  code
    JITTER_PUSH_MAINSTACK(JITTERLISP_FIXNUM_ENCODE(0));
  end
end
instruction push-one ()
  code
    JITTER_PUSH_MAINSTACK(JITTERLISP_FIXNUM_ENCODE(1));
  end
end
instruction push-false ()
  code
    JITTER_PUSH_MAINSTACK(JITTERLISP_FALSE);
  end
end
instruction push-nothing ()
  code
    JITTER_PUSH_MAINSTACK(JITTERLISP_NOTHING);
  end
end

instruction pop-to-register (!R)
  code
    jitterlisp_object top = JITTER_TOP_MAINSTACK();
    JITTER_DROP_MAINSTACK();
    JITTER_ARG0 = top;
  end
end

instruction pop-to-global (?n print_object)
  code
    jitterlisp_object tagged_symbol = JITTER_ARGN0;
    struct jitterlisp_symbol *symbol = JITTERLISP_SYMBOL_DECODE(tagged_symbol);
    symbol->global_value = JITTER_TOP_MAINSTACK();
    JITTER_DROP_MAINSTACK();
  end
end

instruction copy-to-register (!R)
  code
    jitter_int top = JITTER_TOP_MAINSTACK();
    JITTER_ARG0 = top;
  end
end

instruction copy-from-register (?R)
  code
    JITTER_TOP_MAINSTACK() = JITTER_ARG0;
  end
end

instruction copy-from-literal (?n print_object)
  code
    JITTER_TOP_MAINSTACK() = JITTER_ARGN0;
  end
end

instruction literal-to-register (?n print_object, !R)
  code
    JITTER_ARG1 = JITTER_ARGN0;
  end
end

instruction register-to-register (?R, !R)
  code
    JITTER_ARG1 = JITTER_ARG0;
  end
end

instruction branch (?f)
  code
    JITTER_BRANCH_FAST(JITTER_ARGF0);
  end
end

instruction branch-if-false (?f)
  code
    jitterlisp_object top = JITTER_TOP_MAINSTACK();
    JITTER_DROP_MAINSTACK();
    JITTER_BRANCH_FAST_IF_EQUAL(top, JITTERLISP_FALSE, JITTER_ARGF0);
  end
end

instruction branch-if-null (?f)
  code
    jitterlisp_object top = JITTER_TOP_MAINSTACK();
    JITTER_DROP_MAINSTACK();
    JITTER_BRANCH_FAST_IF_EQUAL(top, JITTERLISP_EMPTY_LIST, JITTER_ARGF0);
  end
end

instruction canonicalize-boolean ()
  code
    JITTERLISP_BOOLEAN_CANONICALIZE_(JITTER_TOP_MAINSTACK(),
                                     JITTER_TOP_MAINSTACK());
  end
end

instruction not ()
  code
    JITTERLISP_NOT_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction branch-if-true (?f)
  code
    jitterlisp_object top = JITTER_TOP_MAINSTACK();
    JITTER_DROP_MAINSTACK();
    JITTER_BRANCH_FAST_IF_NOTEQUAL(top, JITTERLISP_FALSE, JITTER_ARGF0);
  end
end

# The first argument is a primitive function pointer.
# The second is its in-arity.
instruction primitive (?n, ?n 0 1 2 3 4)
  code
    jitterlisp_primitive_function p
      = (jitterlisp_primitive_function) JITTER_ARGP0;
    const jitter_uint in_arity = JITTER_ARGN1;
    JITTER_PUSH_UNSPECIFIED_MAINSTACK();
    //asm volatile ("nop");
    jitterlisp_object *first_arg
      = (& JITTER_UNDER_TOP_MAINSTACK()) - in_arity;
    //asm volatile ("nop" : : "X" (first_arg));
    jitterlisp_object res = p (first_arg);
    jitter_uint i;
    // Remove as many elements as the primitive in-arity, but not more:
    // the top unspecified value we pushed will be replaced with the result.
    for (i = 0; i < in_arity; i ++)
      JITTER_NIP_MAINSTACK();
    JITTER_TOP_MAINSTACK() = res;
  end
end

instruction primitive-car ()
  code
    JITTERLISPVM_CHECK_TYPES_1(CONS);
    JITTERLISP_CAR_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-cdr ()
  code
    JITTERLISPVM_CHECK_TYPES_1(CONS);
    JITTERLISP_CDR_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-eqp ()
  code
    JITTERLISPVM_CHECK_TYPES_2(ANYTHING, ANYTHING);
    JITTERLISP_EQP_(JITTER_TOP_MAINSTACK(),
                    JITTER_UNDER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-not-eqp ()
  code
    JITTERLISPVM_CHECK_TYPES_2(ANYTHING, ANYTHING);
    JITTERLISP_NOT_EQP_(JITTER_TOP_MAINSTACK(),
                        JITTER_UNDER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-fixnum-eqp ()
  code
    JITTERLISPVM_CHECK_TYPES_2(FIXNUM, FIXNUM);
    JITTERLISP_EQP_(JITTER_TOP_MAINSTACK(),
                    JITTER_UNDER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-fixnum-not-eqp ()
  code
    JITTERLISPVM_CHECK_TYPES_2(FIXNUM, FIXNUM);
    JITTERLISP_NOT_EQP_(JITTER_TOP_MAINSTACK(),
                        JITTER_UNDER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-zerop ()
  code
    JITTERLISPVM_CHECK_TYPES_1(FIXNUM);
    JITTERLISP_ZEROP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-non-zerop ()
  code
    JITTERLISPVM_CHECK_TYPES_1(FIXNUM);
    JITTERLISP_NON_ZEROP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-positivep ()
  code
    JITTERLISPVM_CHECK_TYPES_1(FIXNUM);
    JITTERLISP_POSITIVEP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-non-positivep ()
  code
    JITTERLISPVM_CHECK_TYPES_1(FIXNUM);
    JITTERLISP_NON_POSITIVEP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-negativep ()
  code
    JITTERLISPVM_CHECK_TYPES_1(FIXNUM);
    JITTERLISP_NEGATIVEP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-non-negativep ()
  code
    JITTERLISPVM_CHECK_TYPES_1(FIXNUM);
    JITTERLISP_NON_NEGATIVEP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-lessp ()
  code
    JITTERLISPVM_CHECK_TYPES_2(FIXNUM, FIXNUM);
    JITTERLISP_LESSP_(JITTER_TOP_MAINSTACK(),
                      JITTER_UNDER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-greaterp ()
  code
    JITTERLISPVM_CHECK_TYPES_2(FIXNUM, FIXNUM);
    JITTERLISP_GREATERP_(JITTER_TOP_MAINSTACK(),
                         JITTER_UNDER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-not-lessp ()
  code
    JITTERLISPVM_CHECK_TYPES_2(FIXNUM, FIXNUM);
    JITTERLISP_NOTLESSP_(JITTER_TOP_MAINSTACK(),
                         JITTER_UNDER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-not-greaterp ()
  code
    JITTERLISPVM_CHECK_TYPES_2(FIXNUM, FIXNUM);
    JITTERLISP_NOTGREATERP_(JITTER_TOP_MAINSTACK(),
                            JITTER_UNDER_TOP_MAINSTACK(),
                            JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-one-plus ()
  code
    JITTERLISPVM_CHECK_TYPES_1(FIXNUM);
    JITTERLISP_1PLUS_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-one-minus ()
  code
    JITTERLISPVM_CHECK_TYPES_1(FIXNUM);
    JITTERLISP_1MINUS_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-two-times ()
  code
    JITTERLISPVM_CHECK_TYPES_1(FIXNUM);
    JITTERLISP_2TIMES_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-two-divided ()
  code
    JITTERLISPVM_CHECK_TYPES_1(FIXNUM);
    JITTERLISP_2DIVIDED_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-two-remainder ()
  code
    JITTERLISPVM_CHECK_TYPES_1(FIXNUM);
    JITTERLISP_2REMAINDER_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-negate ()
  code
    JITTERLISPVM_CHECK_TYPES_1(FIXNUM);
    JITTERLISP_NEGATE_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-primordial-plus ()
  code
    JITTERLISPVM_CHECK_TYPES_2(FIXNUM, FIXNUM);
    JITTERLISP_PLUS_(JITTER_TOP_MAINSTACK(),
                     JITTER_UNDER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-primordial-minus ()
  code
    JITTERLISPVM_CHECK_TYPES_2(FIXNUM, FIXNUM);
    JITTERLISP_MINUS_(JITTER_TOP_MAINSTACK(),
                      JITTER_UNDER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-primordial-times ()
  code
    JITTERLISPVM_CHECK_TYPES_2(FIXNUM, FIXNUM);
    JITTERLISP_TIMES_(JITTER_TOP_MAINSTACK(),
                      JITTER_UNDER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-primordial-divided-unsafe ()
  code
    /* The second argument has already been validated if we are using this. */
    JITTERLISPVM_CHECK_TYPES_2(FIXNUM, ANYTHING);
    JITTERLISP_DIVIDED_UNSAFE_(JITTER_TOP_MAINSTACK(),
                               JITTER_UNDER_TOP_MAINSTACK(),
                               JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-quotient-unsafe ()
  code
    /* The second argument has already been validated if we are using this. */
    JITTERLISPVM_CHECK_TYPES_2(FIXNUM, ANYTHING);
    JITTERLISP_QUOTIENT_UNSAFE_(JITTER_TOP_MAINSTACK(),
                               JITTER_UNDER_TOP_MAINSTACK(),
                               JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-remainder-unsafe ()
  code
    /* The second argument has already been validated if we are using this. */
    JITTERLISPVM_CHECK_TYPES_2(FIXNUM, ANYTHING);
    JITTERLISP_REMAINDER_UNSAFE_(JITTER_TOP_MAINSTACK(),
                                 JITTER_UNDER_TOP_MAINSTACK(),
                                 JITTER_TOP_MAINSTACK());
    JITTER_NIP_MAINSTACK();
  end
end

instruction primitive-nullp ()
  code
    JITTERLISP_NULLP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-non-nullp ()
  code
    JITTERLISP_NON_NULLP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-nothingp ()
  code
    JITTERLISP_NOTHINGP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-fixnump ()
  code
    JITTERLISP_FIXNUMP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-characterp ()
  code
    JITTERLISP_CHARACTERP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-consp ()
  code
    JITTERLISP_CONSP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-non-consp ()
  code
    JITTERLISP_NON_CONSP_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-not ()
  code
    JITTERLISP_NOT_(JITTER_TOP_MAINSTACK(), JITTER_TOP_MAINSTACK());
  end
end

instruction primitive-boolean-canonicalize ()
  code
    JITTERLISP_BOOLEAN_CANONICALIZE_(JITTER_TOP_MAINSTACK(),
                                     JITTER_TOP_MAINSTACK());
  end
end

instruction call (?n 0 1 2 3 4 5 6 7 8 9 10)
  caller
  code
    jitterlisp_object callee = JITTER_AT_DEPTH_MAINSTACK(JITTER_ARGN0);
    struct jitterlisp_closure *c = JITTERLISP_CLOSURE_DECODE(callee);
    JITTER_PUSH_UNSPECIFIED_RETURNSTACK();
    JITTER_BRANCH_AND_LINK(c->compiled.code);
  end
end

instruction tail-call (?n)
#  caller
  code
    /* FIXME: this is currently a dummy instruction, always rewritten away. */
  end
end

instruction procedure-prolog ()
  callee
  code
    JITTER_TOP_RETURNSTACK() = (jitterlisp_object) JITTER_LINK;
  end
end

instruction return ()
  code
    jitter_uint return_address = JITTER_TOP_RETURNSTACK();
    JITTER_DROP_RETURNSTACK();
    JITTER_RETURN(return_address);
  end
end

instruction save-register (?R)
  code
    JITTER_PUSH_RETURNSTACK(JITTER_ARG0);
  end
end

instruction restore-register (!R)
  code
    JITTER_ARG0 = JITTER_TOP_RETURNSTACK();
    JITTER_DROP_RETURNSTACK();
  end
end




## Optimization rewrites.
#################################################################

rule
  rewrite
    pop-to-register $a; push-register $b
  into
    copy-to-register $a; copy-from-register $b
end

rule
  rewrite
    pop-to-register $a; push-literal $b
  into
    copy-to-register $a; copy-from-literal $b
end

rule
  rewrite
    push-literal $a; pop-to-register R $b
  into
    literal-to-register $a, $b
end

rule
  rewrite
    drop; push-register R $a
  into
    copy-from-register $a
end

rule
  rewrite
    drop; push-literal $a
  into
    copy-from-literal $a
end

rule
  rewrite
    push-register R $a; pop-to-register R $b
  into
    register-to-register $a, $b
end

rule
  rewrite
    copy-from-register R $a; pop-to-register R $b
  into
    register-to-register $a, $b; drop
end

rule
  rewrite
    copy-from-literal $a; pop-to-register R $b
  into
    literal-to-register $a, $b; drop
end

rule
  rewrite
    push-register $a; push-register $a
  into
    push-register $a; dup
end

rule
  rewrite
    copy-from-register $a; push-register $a
  into
    copy-from-register $a; dup
end

rule
  rewrite
    copy-to-register $a; push-register $a
  into
    copy-to-register $a; dup
end

rule
  rewrite
    copy-to-register $a; copy-from-register $a
  into
    copy-to-register $a
end

rule
  rewrite
    push-literal $a; push-literal $a
  into
    push-literal $a; dup
end

rule
  rewrite
    copy-from-literal $a; push-literal $a
  into
    copy-from-literal $a; dup
end

rule
  rewrite
    push-register $a; drop
  into
    # Nothing.
end

rule
  rewrite
    push-literal $a; drop
  into
    # Nothing.
end

rule
  rewrite
    pop-to-register $a; copy-from-register $a
  into
    copy-to-register $a; nip
end

rule
  rewrite
    pop-to-register $a; drop
  into
    nip; pop-to-register $a
end

rule
  rewrite
    drop; drop
  into
    nip; drop
end

# Having copy-to-register at the end might make it possible to combine
# with some other instruction; nip is not easy to combine, and in fact
# I currently have no other rule with nip on the left.
rule
  rewrite
    copy-to-register $a; nip
  into
    nip; copy-to-register $a
end

rule
  rewrite
    pop-to-register $a; return
  into
    drop; return
end

rule
  rewrite
    copy-to-register $a; return
  into
    return
end

# FIXME: this is a temporary kludge, to be used before I actually implement
# tail calls.
rule
  rewrite
    tail-call $a
  into
    call $a; return
end
