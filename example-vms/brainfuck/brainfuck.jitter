## An efficient Jitter virtual machine for the Brainfuck language.

## Copyright (C) 2017 Luca Saiu
## Written by Luca Saiu

## This file is part of Jitter.

## Jitter is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.

## Jitter is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.

## You should have received a copy of the GNU General Public License
## along with Jitter.  If not, see <http://www.gnu.org/licenses/>.


## Global configuration
#################################################################

vm
  set prefix "brainfuckvm"
end #vm


## C code to use.
#################################################################

early-c
  code
    #include <string.h>
  end #code
end #early-c

late-c
  code
    #define HEAD_ADDRESS     (s.register_0.pointer)
    #define UNDER_HEAD_VALUE (*((unsigned char*)HEAD_ADDRESS))

    /* This is only used with optimized instructions. */
    #define CELL_CACHE       (s.register_1.unsigned_fixnum)
  end #code
end #late-c

state-struct-c
  code
    unsigned char *tape;
  end #code
end #state-struct-c

initialization-c
  code
    if ((s.tape = malloc (30000)) == NULL)
      jitter_fatal ("could not allocate tape");
    memset (s.tape, 0, 30000);
    HEAD_ADDRESS = (void*)s.tape;
  end #code
end #initialization-c

finalization-c
  code
    free (s.tape);
  end #code
end #finalization-c


## Functions and globals to wrap.
#################################################################

wrapped-functions
  getchar
  putchar
end #wrapped-functions

wrapped-globals
end #wrapped-globals


## Tape move meta-instructions.
#################################################################

instruction left ()
  code
    HEAD_ADDRESS = (void*)((char*)HEAD_ADDRESS - 1);
  end
end #instruction

instruction right ()
  code
    HEAD_ADDRESS = (void*)((char*)HEAD_ADDRESS + 1);
  end #code
end #instruction

instruction move (?n 1 -1 -10 -9 -8 -7 -6 -5 -4 -3 -2 2 3 4 5 6 7 8 9 10)
  code
    HEAD_ADDRESS = (void*)((char*)HEAD_ADDRESS + JITTER_ARGN0);
  end #code
end #instruction


## Tape access (only for optimization).
#################################################################

instruction load ()
  code
    CELL_CACHE = UNDER_HEAD_VALUE;
  end #code
end #instruction

instruction store ()
  code
    UNDER_HEAD_VALUE = CELL_CACHE;
  end #code
end #instruction


## Head meta-instructions.
#################################################################

instruction plusunoptimized ()
  code
    UNDER_HEAD_VALUE ++;
  end #code
end #instruction

instruction minusunoptimized ()
  code
    UNDER_HEAD_VALUE --;
  end #code
end #instruction

instruction update (?n 1 -1 -10 -9 -8 -7 -6 -5 -4 -3 -2 2 3 4 5 6 7 8 9 10)
  code
    UNDER_HEAD_VALUE += JITTER_ARGN0;
  end #code
end #instruction

instruction plusoptimized ()
  code
    CELL_CACHE ++;
  end #code
end #instruction

instruction minusoptimized ()
  code
    CELL_CACHE --;
  end #code
end #instruction

instruction updateoptimized (?n 1 -1 -10 -9 -8 -7 -6 -5 -4 -3 -2 2 3 4 5 6 7 8 9 10)
  code
    CELL_CACHE += JITTER_ARGN0;
  end #code
end #instruction


## Control meta-instructions.
#################################################################

# Mostly for debugging.
instruction branch (?l)
  code
    JITTER_BRANCH (JITTER_ARGP0);
  end #code
end #instruction

instruction branchonzerounoptimized (?l)
  code
    if (UNDER_HEAD_VALUE == 0)
      JITTER_BRANCH (JITTER_ARGP0);
  end #code
end #instruction

instruction branchonnonzerounoptimized (?l)
  code
    if (UNDER_HEAD_VALUE != 0)
      JITTER_BRANCH (JITTER_ARGP0);
  end #code
end #instruction

instruction branchonzerooptimized (?l)
  code
    if (CELL_CACHE == 0)
      JITTER_BRANCH (JITTER_ARGP0);
  end #code
end #instruction

instruction branchonnonzerooptimized (?l)
  code
    if (CELL_CACHE != 0)
      JITTER_BRANCH (JITTER_ARGP0);
  end #code
end #instruction


## I/O meta-instructions.
#################################################################

instruction inputunoptimized ()
  code
    UNDER_HEAD_VALUE = getchar ();
  end #code
end #instruction

instruction outputunoptimized ()
  code
    putchar (UNDER_HEAD_VALUE);
  end #code
end #instruction

instruction inputoptimized ()
  code
    CELL_CACHE = getchar ();
  end #code
end #instruction

instruction outputoptimized ()
  code
    putchar (CELL_CACHE);
  end #code
end #instruction


## End.
#################################################################
