/* eh-frame.pk - EH_FRAME imlementation for GNU poke.
                 Unwind Information.  */

/* Copyright (C) 2021 Oracle Inc.  */

/* This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

load leb128;
load "dwarf-common.pk";

/* DWARF Common Information Entry (CIE)

   There is at least one CIE in every non-empty .eh_frame
   section.  */

type Dwarf_CIE =
  struct
  {
    /* Size of the CIE structure, not including the `length' field
       itself.  */
    offset<uint<32>,B> length;

    /* Constant used to distinguish CIEs from FDEs.  */
    uint<32> cie_id == 0;

    /* This version number is specific to the call frame information
       and is independent of the DWARF version number.  */
    uint<8> version : ((dwarf_version == 2 && version == 1)
                       || (dwarf_version == 3 && version == 3)
                       || (dwarf_version == 4 && version == 4)
                       || version == 1 /* GAS generates version 1.  */);

    /* UTF-8 string that identifies the augmentation to this CIE or to
       the FDEs that use it.  If there is no augmentation this value
       is a zero byte.  */
    string augmentation;

    union
    {
      struct
      {
	/* Size of a target address in this CIE and any FDEs that use it.
	   If a CU exists for this frame, its address size must match the
	   address size here.  */
	offset<uint<8>,B> address_size;

	/* Size of a segment selector in this CIE and any FDEs that use
	   it.  */
	offset<uint<8>,B> segment_size;
      } d : version >= 4;
      struct {} nothing;
    } sz;

    /* A constant that is factored out of all advance location
       instructions.  */
    ULEB128 code_alignment_factor;

    /* A constant that is factored out of certain offset
       instructions.  */
    LEB128 data_alignment_factor;

    union
      {
	/* Constant that indicates which column in the rule table
	   represents the return address of the function.  */
	ULEB128 ra_uleb : version == 1;
	uint<8> ra;
      } return_column;

    union
      {
	ULEB128 size : augmentation[0] == 'z';
	struct {} nothing;
      } aug;

    union
      {
	byte encoding : augmentation[1] == 'L';
	struct {} nothing;
      } lsda;

    union
      {
	byte encoding : (augmentation[1] == 'R' || augmentation[2] == 'R');
	struct {} nothing;
      } fde;

    /* Use unread_bytes for now.
       This is where DWARF_CFI instructions appear.  */
    var unread_bytes = length + 4#B - OFFSET;
    byte[unread_bytes] unread_data;
    // var insn_size = length + 4#B - OFFSET;
    // Dwarf_CFI[insn_size] initial_instructions;
  };

/* DWARF FDE.
   Description of a frame for a given function.  */

type Dwarf_FDE =
  struct
  {
    /* Size of the header and instruction stream for this function,
       not including the `length' field itself.  */
    offset<uint<32>,B> length;

    /* Offset into the .eh_frame section that denotes the CIE that
       is associated with this FDE.  */
    uint<32> cie_pointer;

    /* XXX initial_location (segment selector and target address)  */
    uint<32> code_offset;

    /* Number of bytes of program instructions described by this
       entry.  */
    uint<32> code_length;

    ULEB128 augmentation_size;

    var unread_bytes = length + 4#B - OFFSET;
    byte[unread_bytes] unread_data;

    /* var padding = (length.value
                      - (cie_pointer'size + initial_location'size
                         + address_range'size + address_range.value()#B)); */

    /* Dwarf_CFI[address_range.value()#B + padding] instructions; */
  };


type Eh_Frame_Section_Entry =
  union
  {
    Dwarf_CIE cie : cie.cie_id == 0;
    Dwarf_FDE fde;
  };

type Eh_Frame_Section =
  struct
  {
    Eh_Frame_Section_Entry[] eh_frame_entries;
  };


fun eh_frame_dump_fde_code_offset = (Eh_Frame_Section eh_frame) void:
{
    var i = 0;
      for (ent in eh_frame.eh_frame_entries)
	{
	  try
	    {
	      printf ("%u32d:   %v \n", i++, ent.fde.code_offset);
	    }
	    catch if E_elem
	    {
	    }
	}
}

