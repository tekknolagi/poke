## Process this file with automake to produce Makefile.in .
# Copyright (C) 2016, 2017, 2018, 2019, 2020 Luca Saiu
# Written by Luca Saiu

# This file is part of the Jitter structured-language example,
# distributed along with Jitter under the same license.

# Jitter is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# Jitter is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with Jitter.  If not, see <http://www.gnu.org/licenses/>.


# Jitter as a sub-package.
################################################################

# Build Jitter as a sub-package.
#
# This assumes that the Jitter source directory has been copied or symbolically
# linked to as "jitter" within the current directory.
SUBDIRS = jitter


# General settings.
################################################################

# We have source files in subdirectories.
AUTOMAKE_OPTIONS = subdir-objects


# What we have to build.
################################################################

# Apart from the examples we only have one program, the "structured language"
# executable.
bin_PROGRAMS = bin/structured
bin_structured_SOURCES = \
  structured-syntax.h \
  structured-syntax.c \
  structured-code-generator.h \
  structured-code-generator.c \
  structured-code-generator-stack.h \
  structured-code-generator-stack.c \
  structured-code-generator-register.h \
  structured-code-generator-register.c \
  $(GENERATED_C_FILES_FOR_STRUCTUREDVM) \
  structured-main.c

# The structured executable must be built using the preprocessor, compiler and
# linker options mandated by Jitter -- in this case we only use the default
# Jitter dispatching mode as selected at configure time, which is what most
# people will want.
# The fourth line is not a mistake: Automake provides no AM_LDADD variable.
bin_structured_CPPFLAGS = \
  $(AM_CPPFLAGS) $(JITTER_CPPFLAGS) $(JITTER_LIBTEXTSTYLE_CPPFLAGS)
bin_structured_CFLAGS = $(AM_CFLAGS) $(JITTER_CFLAGS)
bin_structured_LDFLAGS = $(AM_LDFLAGS) $(JITTER_LDFLAGS)
bin_structured_LDADD = $(JITTER_LDADD) $(JITTER_LIBTEXTSTYLE_LDADD)


# Machine-generated C files.
################################################################

# The structured program relies on several machine-generated sources: some
# generated by Jitter, others by Flex and Bison.
# All the machine-generated C files are in the source directory.  I find this
# to be easier to manage, with the user distributed tree looking the same as
# my development tree; in this case every built C file is also distributed.
GENERATED_C_FILES_FOR_STRUCTUREDVM = \
  structuredvm-vm.h structuredvm-vm1.c structuredvm-vm2.c \
  structured-scanner.c structured-scanner.h \
  structured-parser.c structured-parser.h
BUILT_SOURCES = $(GENERATED_C_FILES_FOR_STRUCTUREDVM)


# Jitter C-code generation.
################################################################

# Jitter-generated files for the structured-language VM.  Here by convention all
# the generated files but the first depend on the first, even if they are all
# generated at the same time.
# These generated files are distributed by default, and the (problematic)
# dependency from $(JITTER) to them is not tracked explicitly: it would
# interfere with BUILT_SOURCES, which serves to build machine-generated sources
# very early in the build process.
$(srcdir)/structuredvm-vm.h: structured.jitter
	$(MAKE) -C jitter
	$(JITTER) "$(srcdir)/structured.jitter" --output "$(srcdir)"
$(srcdir)/structuredvm-vm1.c: structuredvm-vm.h
$(srcdir)/structuredvm-vm2.c: structuredvm-vm.h


# Frontend C-code generation.
################################################################

# There is nothing special related to Jitter here; I am just using Flex and
# Bison to generate a scanner and a parser, in a canonical way.
# Flex and Bison generate two files each (one ".c" and one ".h" file); here
# by convention each ".h" file depends on its companion ".c" file, actually
# generated at the same time.
$(srcdir)/structured-parser.c: structured.y
	$(YACC) -o "$@" "$(srcdir)/structured.y"
$(srcdir)/structured-parser.h: structured-parser.c
$(srcdir)/structured-scanner.c: structured.l
	$(LEX) --header-file="$(srcdir)/structured-scanner.h" -o"$@" \
          "$(srcdir)/structured.l"
$(srcdir)/structured-scanner.h: structured-scanner.c


# Files to be distributed.
################################################################

# The Autoconf definitions copied from Jitter into build-aux/jitter.m4 do need
# to be distributed, but the Autotools automatically discover this automatically
# from the simple use of AC_CONFIG_MACRO_DIR in configure.ac , along (I suppose)
# with the fact that the Autoconf macros are actually used.
#
# Of course the Jitter, Flex and Bison sources have to be distributed: they are
# the actual human-written sources.
#
# It is not inconceavable that, in some cross- configurations, we have a jitterc
# working on the host platform but not on the build platform.  In that case we
# can still do something useful as long as we distribute the C files generated
# by Jitter.  Since we also distribute the C files generated by Flex and Bison,
# as per the GNU coding standards, this means that in this case every file in
# $(BUILT_SOURCES) is also distributed.
EXTRA_DIST = \
  structured.jitter \
  $(BUILT_SOURCES) \
  structured.l structured.y \
  examples/count-down.structured \
  examples/count-up-down.structured \
  examples/euclid.structured \
  examples/primes.structured \
  examples/primes.c \
  structured-style.css


# Benchmarking examples.
################################################################

EXTRA_PROGRAMS = examples/primes-in-c
examples_primes_in_c_SOURCES = examples/primes.c

examples: $(EXTRA_PROGRAMS)
benchmarks: $(EXTRA_PROGRAMS)


# Benchmarking examples for the user, not to be compiled.
################################################################

# The user is free to play with those translations of the primes.structured
# example into other languages, but they are not automatically compiled.
EXTRA_DIST += \
  examples/primes.java \
  examples/primes.py


# Cleanup.
################################################################

# This entire section serves to make this build system live inside the main one,
# in a slightly anonymous way.  A user learning how to build Jitter into her own
# program from this Makefile.am can ignore all of this.

# This is a special package, meant to include the Jitter sources as a
# subdirectory but in fact distributed as part of Jitter as an example,
# itself contained within the Jitter sources.
# In this case I do not want to be bothered by generated files, so I let
# maintainer-clean be particularly aggressive, more than the GNU coding
# standards recommend.
maintainer-clean-aggressive:
	for basename in $(BUILT_SOURCES) \
                        configure Makefile.in \
                        aclocal.m4 config.h.in \
                        INSTALL build-aux; do \
          rm -rf "$(srcdir)/$${basename}"; \
	done
	rm -f "$(srcdir)/aclocal.m4" "$(srcdir)/config.h.in"

# I have separated the rule for maintainer-clean-aggressive in order to make it
# stand here.  A real production software using Jitter should *not* do any of
# this on maintainer-clean .
maintainer-clean-local: maintainer-clean-aggressive
