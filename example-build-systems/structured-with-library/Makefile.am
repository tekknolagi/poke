## Process this file with automake to produce Makefile.in .
# Copyright (C) 2016, 2017, 2018, 2019, 2020 Luca Saiu
# Updated in 2021 by Luca Saiu
# Written by Luca Saiu

# This file is part of the Jitter structured-language example,
# distributed along with Jitter under the same license.

# Jitter is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# Jitter is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with Jitter.  If not, see <http://www.gnu.org/licenses/>.


# Jitter as a sub-package.
################################################################

# Build Jitter as a sub-package.
#
# This assumes that the Jitter source directory has been copied or symbolically
# linked to as "jitter" within the current directory.
SUBDIRS = jitter

# Compile every source defining the feature macro to enable the Libtextstyle
# wrapper.  It is harmless to supply it even when not used.
AM_CPPFLAGS = $(JITTER_LIBTEXTSTYLE_CPPFLAGS)


# General settings.
################################################################

# We have source files in subdirectories.
AUTOMAKE_OPTIONS = subdir-objects


# What we have to build.
################################################################

# Apart from the examples we only have one program, the "structured language"
# executable.
#
# With this Makefile.am (differently from the one in structured-simple/ ) we
# list every C file except the ones generated by Jitter as part of the program
# sources.  Frontend files, generated by Flex and Bison, are part of the
# program sources and not part of the library.
#
# The files generated by Jitter will be part of a convenience library,
# "libstructuredvm", defined below.
#
# For the main program sources we need to use the CPPFLAGS from Jitter in order
# to make accessible header files and macros, but we need no special CFLAGS.
# This is good: everything in the program except the VM will be fully optimized.
bin_PROGRAMS = bin/structured
bin_structured_SOURCES = \
  structured-syntax.h \
  structured-syntax.c \
  structured-code-generator.h \
  structured-code-generator.c \
  structured-code-generator-stack.h \
  structured-code-generator-stack.c \
  structured-code-generator-register.h \
  structured-code-generator-register.c \
  $(FRONTEND_GENERATED_FILES) \
  structured-main.c
bin_structured_CPPFLAGS = $(AM_CPPFLAGS) $(JITTER_CPPFLAGS)

# bin/structured depends on a Libtool convenience library and is linked to it.
bin_structured_LDADD = -lstructuredvm  $(JITTER_LIBTEXTSTYLE_LDADD)
bin_structured_DEPENDENCIES = libstructuredvm.la
bin_structured_LDFLAGS = -L$(abs_top_builddir)

# The Libtool convenience library libstructuredvm.la has the Jitter-generated
# files as sources.  It contains the VM C implementation, and therefore needs to
# be compiled with care by supplying the correct CFLAGS.
#
# The Jitter runtime library will be part of libstructuredvm.la , thanks to the
# _LIBADD varaiable: the main program is not linked to the Jitter runtime, but
# only to the "libstructuredvm" runtime.
noinst_LTLIBRARIES = libstructuredvm.la
libstructuredvm_la_SOURCES = $(JITTER_GENERATED_FILES)
libstructuredvm_la_CFLAGS = $(AM_CFLAGS) $(JITTER_CFLAGS)
libstructuredvm_la_CPPFLAGS = $(AM_CPPFLAGS) $(JITTER_CPPFLAGS)
libstructuredvm_la_LIBADD = $(JITTER_LIBADD)
libstructuredvm_la_LDFLAGS = $(AM_LDFLAGS) $(JITTER_LDFLAGS)


# Machine-generated C files.
################################################################

# The structured program relies on several machine-generated sources: some
# generated by Jitter, others by Flex and Bison.
# All the machine-generated C files are in the source directory.  I find this
# to be easier to manage, with the user distributed tree looking the same as
# my development tree; in this case every built C file is also distributed.
GENERATED_C_FILES_FOR_STRUCTUREDVM = \
  $(JITTER_GENERATED_FILES) \
  $(FRONTEND_GENERATED_FILES)
BUILT_SOURCES = $(GENERATED_C_FILES_FOR_STRUCTUREDVM)


# Jitter C-code generation.
################################################################

JITTER_GENERATED_FILES = \
  structuredvm-vm.h structuredvm-vm1.c structuredvm-vm2.c

# Jitter-generated files for the structured-language VM.  Here by convention all
# the generated files but the first depend on the first, even if they are all
# generated at the same time.
# These generated files are distributed.
$(srcdir)/structuredvm-vm.h: structured.jitter
	$(MAKE) -C jitter
	$(JITTER) "$(srcdir)/structured.jitter" --output "$(srcdir)"
$(srcdir)/structuredvm-vm1.c: structuredvm-vm.h
$(srcdir)/structuredvm-vm2.c: structuredvm-vm.h


# Frontend C-code generation.
################################################################

FRONTEND_GENERATED_FILES = \
  structured-scanner.c structured-scanner.h \
  structured-parser.c structured-parser.h

# There is nothing special related to Jitter here; I am just using Flex and
# Bison to generate a scanner and a parser, in a canonical way.
# Flex and Bison generate two files each (one ".c" and one ".h" file); here
# by convention each ".h" file depends on its companion ".c" file, actually
# generated at the same time.
$(srcdir)/structured-parser.c: structured.y
	$(YACC) -o "$@" "$(srcdir)/structured.y"
$(srcdir)/structured-parser.h: structured-parser.c
$(srcdir)/structured-scanner.c: structured.l
	$(LEX) --header-file="$(srcdir)/structured-scanner.h" -o"$@" \
          "$(srcdir)/structured.l"
$(srcdir)/structured-scanner.h: structured-scanner.c


# Files to be distributed.
################################################################

# The Autoconf definitions copied from Jitter into build-aux/jitter.m4 do need
# to be distributed, but the Autotools automatically discover this automatically
# from the simple use of AC_CONFIG_MACRO_DIR in configure.ac , along (I suppose)
# with the fact that the Autoconf macros are actually used.
#
# Of course the Jitter, Flex and Bison sources have to be distributed: they are
# the actual human-written sources.
#
# It is not inconceavable that, in some cross- configurations, we have a jitterc
# working on the host platform but not on the build platform.  In that case we
# can still do something useful as long as we distribute the C files generated
# by Jitter.  Since we also distribute the C files generated by Flex and Bison,
# as per the GNU coding standards, this means that in this case every file in
# $(BUILT_SOURCES) is also distributed.
EXTRA_DIST = \
  structured.jitter \
  $(BUILT_SOURCES) \
  structured.l structured.y \
  examples/count-down.structured \
  examples/count-primes.structured \
  examples/count-up-down.structured \
  examples/euclid.structured \
  examples/primes.structured \
  examples/count-primes.c \
  examples/primes.c \
  structured-style.css


# Benchmarking examples.
################################################################

EXTRA_PROGRAMS = examples/count-primes-in-c examples/primes-in-c
examples_count_primes_in_c_SOURCES = examples/count-primes.c
examples_primes_in_c_SOURCES = examples/primes.c

examples: $(EXTRA_PROGRAMS)
benchmarks: $(EXTRA_PROGRAMS)


# Benchmarking examples for the user, not to be compiled.
################################################################

# The user is free to play with those translations of the primes.structured
# example into other languages, but they are not automatically compiled.
EXTRA_DIST += \
  examples/primes.java \
  examples/primes.py \
  structured-style.css


# Cleanup.
################################################################

# This entire section serves to make this build system live inside the main one,
# in a slightly anonymous way.  A user learning how to build Jitter into her own
# program from this Makefile.am can ignore all of this.

# This is a special package, meant to include the Jitter sources as a
# subdirectory but in fact distributed as part of Jitter as an example,
# itself contained within the Jitter sources.
# In this case I do not want to be bothered by generated files, so I let
# maintainer-clean be particularly aggressive, more than the GNU coding
# standards recommend.
maintainer-clean-aggressive:
	for basename in $(BUILT_SOURCES) \
                        configure Makefile.in \
                        aclocal.m4 config.h.in \
                        INSTALL build-aux; do \
          rm -rf "$(srcdir)/$${basename}"; \
	done
	rm -f "$(srcdir)/aclocal.m4" "$(srcdir)/config.h.in"

# I have separated the rule for maintainer-clean-aggressive in order to make it
# stand here.  A real production software using Jitter should *not* do any of
# this on maintainer-clean .
maintainer-clean-local: maintainer-clean-aggressive
